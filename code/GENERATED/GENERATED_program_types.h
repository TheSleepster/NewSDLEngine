// THIS IS GENERATED BY THE PREPROCESSOR
// THIS IS THE RTTI FOR THE ENTIRE PROGRAM

#ifndef GENERATED_PROGRAM_TYPES_H
#define GENERATED_PROGRAM_TYPES_H

#include <preprocessor_type_data.h>

enum GENERATED_program_types_t {
	TYPE_memory_arena_footer_t,
	TYPE_byte,
	TYPE_u64,
	TYPE_memory_arena_t,
	TYPE_bool32,
	TYPE_u32,
	TYPE_scratch_arena_t,
	TYPE_u8,
	TYPE_dynarray_header_t,
	TYPE_zone_allocator_t,
	TYPE_file_t,
	TYPE_sys_handle_t,
	TYPE_string_t,
	TYPE_bool8,
	TYPE_mapped_file_t,
	TYPE_file_data_t,
	TYPE_overlap_io_data_t,
	TYPE_visit_file_data_t,
	TYPE_visit_files_pfn_t,
	TYPE_void,
	TYPE_file_watcher_t,
	TYPE_file_watcher_recorded_change_t,
	TYPE_file_watcher_callback_pfn_t,
	TYPE_file_watcher_change_event_t,
	TYPE_file_watcher_sys_watch_data_t,
	TYPE_vec2_t,
	TYPE_global_context_t,
	TYPE_threadpool_t,
	TYPE_hash_table_header_t,
	TYPE_program_flag_data_t,
	TYPE_float32,
	TYPE_char,
	TYPE_program_flag_t,
	TYPE_arg_type_t,
	TYPE_program_flag_state_t,
	TYPE_string_builder_buffer_t,
	TYPE_string_builder_t,
	TYPE_sys_thread_t,
	TYPE_sys_thread_handle_t,
	TYPE_sys_mutex_t,
	TYPE_sys_mutex_handle_t,
	TYPE_sys_semaphore_t,
	TYPE_sys_semaphore_handle_t,
	TYPE_threadpool_queue_entry_t,
	TYPE_threadpool_callback_t,
	TYPE_threadpool_queue_t,
	TYPE_zone_allocator_block_t,
	TYPE_entity_t,
	TYPE_entity_manager_t,
	TYPE_game_state_t,
	TYPE_input_data_t,
	TYPE_client_data_t,
	TYPE_sockaddr_storage,
	TYPE_socklen_t,
	TYPE_SDL_Window,
	TYPE_s32,
	TYPE_sockaddr_in_t,
	TYPE_render_geometry_instance_t,
	TYPE_mat4_t,
	TYPE_vec4_t,
	TYPE_render_geometry_batch_t,
	TYPE_render_camera_t,
	TYPE_render_group_t,
	TYPE_render_pipeline_state_t,
	TYPE_asset_handle_t,
	TYPE_texture2D_t,
	TYPE_draw_frame_t,
	TYPE_render_state_t,
	TYPE_vulkan_render_context_t,
	TYPE_vulkan_render_frame_state_t,
	TYPE_alignas_t,
	TYPE_global_matrix_uniforms_t,
	TYPE_push_constant_t,
	TYPE_vulkan_buffer_data_t,
	TYPE_VkBuffer,
	TYPE_VkDeviceMemory,
	TYPE_VkBufferUsageFlagBits,
	TYPE_vulkan_pipeline_data_t,
	TYPE_VkPipeline,
	TYPE_VkPipelineBindPoint,
	TYPE_VkPipelineLayout,
	TYPE_spv_vulkan_type_map_t,
	TYPE_SpvReflectDescriptorType,
	TYPE_VkDescriptorType,
	TYPE_vulkan_shader_descriptor_set_info_t,
	TYPE_VkDescriptorSetLayoutBinding,
	TYPE_VkImageView,
	TYPE_VkSampler,
	TYPE_VkDescriptorSet,
	TYPE_vulkan_shader_uniform_texture_data_t,
	TYPE_vulkan_shader_uniform_data_range_t,
	TYPE_vulkan_shader_uniform_data_t,
	TYPE_vulkan_shader_descriptor_set_binding_type_t,
	TYPE_vulkan_shader_stage_info_t,
	TYPE_VkShaderStageFlagBits,
	TYPE_VkShaderModuleCreateInfo,
	TYPE_VkPipelineShaderStageCreateInfo,
	TYPE_VkShaderModule,
	TYPE_vulkan_shader_data_t,
	TYPE_SpvReflectShaderModule,
	TYPE_VkDescriptorPool,
	TYPE_VkDescriptorSetLayout,
	TYPE_VkPushConstantRange,
	TYPE_vulkan_physical_device_swapchain_support_info_t,
	TYPE_VkSurfaceCapabilitiesKHR,
	TYPE_VkSurfaceFormatKHR,
	TYPE_VkPresentModeKHR,
	TYPE_vulkan_physical_device_queue_info_t,
	TYPE_vulkan_physical_device_requirements_t,
	TYPE_vulkan_physical_device_t,
	TYPE_VkPhysicalDevice,
	TYPE_VkFormat,
	TYPE_VkPhysicalDeviceProperties,
	TYPE_VkPhysicalDeviceFeatures,
	TYPE_VkPhysicalDeviceMemoryProperties,
	TYPE_vulkan_rendering_device_t,
	TYPE_VkQueue,
	TYPE_VkCommandPool,
	TYPE_VkDevice,
	TYPE_vulkan_fence_t,
	TYPE_VkFence,
	TYPE_vulkan_renderpass_data_t,
	TYPE_VkRenderPass,
	TYPE_vulkan_renderpass_state_t,
	TYPE_vulkan_framebuffer_data_t,
	TYPE_VkFramebuffer,
	TYPE_vulkan_image_data_t,
	TYPE_VkImage,
	TYPE_VkImageLayout,
	TYPE_vulkan_texture_t,
	TYPE_vulkan_swapchain_data_t,
	TYPE_VkSwapchainKHR,
	TYPE_vulkan_command_buffer_data_t,
	TYPE_VkCommandBuffer,
	TYPE_vulkan_command_buffer_state_t,
	TYPE_vulkan_render_backend_function_data_t,
	TYPE_VkSemaphore,
	TYPE_VkInstance,
	TYPE_VkAllocationCallbacks,
	TYPE_VkSurfaceKHR,
	TYPE_VkDebugUtilsMessengerEXT,
	TYPE_asset_manager_t,
	TYPE_asset_slot_t,
	TYPE_subtexture_data_t,
	TYPE_texture_atlas_t,
	TYPE_jfd_package_entry_t,
	TYPE_jfd_file_header_t,
	TYPE_asset_type_t,
	TYPE_bitmap_t,
	TYPE_shader_t,
	TYPE_material_t,
	TYPE_asset_slot_load_status_t,
	TYPE_asset_manager_asset_file_data_t,
	TYPE_asset_catalog_t,
	TYPE_texture_atlas_registry_t,
	TYPE_action_button_t,
	TYPE_keyboard_controller_data_t,
	TYPE_analog_button_t,
	TYPE_s16,
	TYPE_gamepad_controller_data_t,
	TYPE_SDL_Gamepad,
	TYPE_SDL_Joystick,
	TYPE_input_controller_t,
	TYPE_controller_type_t,
	TYPE_game_action_binding_t,
	TYPE_game_action_t,
	TYPE_input_manager_t,
	TYPE_packet_t,
};

struct type_info_memory_arena_footer_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t last_base;
		type_info_member_t last_used;
		type_info_member_t last_block_size;
	}members;
};

struct type_info_memory_arena_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_initialized;
		type_info_member_t base;
		type_info_member_t used;
		type_info_member_t block_size;
		type_info_member_t block_counter;
		type_info_member_t scratch_arena_count;
	}members;
};

struct type_info_scratch_arena_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t parent;
		type_info_member_t base;
		type_info_member_t used;
	}members;
};

struct type_info_dynarray_header_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t flags;
		type_info_member_t size;
		type_info_member_t capacity;
		type_info_member_t header_id;
	}members;
};

struct type_info_file_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t handle;
		type_info_member_t file_name;
		type_info_member_t filepath;
		type_info_member_t file_size;
		type_info_member_t current_read_offset;
		type_info_member_t current_write_offset;
		type_info_member_t overlapping;
		type_info_member_t for_writing;
	}members;
};

struct type_info_mapped_file_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t file;
		type_info_member_t mapping_handle;
		type_info_member_t mapped_file_data;
	}members;
};

struct type_info_file_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t last_modtime;
		type_info_member_t file_size;
		type_info_member_t filename;
		type_info_member_t filepath;
	}members;
};

struct type_info_overlap_io_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t offset_to_read;
		type_info_member_t bytes_to_read;
		type_info_member_t status;
		type_info_member_t bytes_transfered;
		type_info_member_t event_handle;
	}members;
};

struct type_info_visit_file_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t function;
		type_info_member_t user_data;
		type_info_member_t filename;
		type_info_member_t fullname;
		type_info_member_t recursive;
		type_info_member_t is_directory;
	}members;
};

struct type_info_file_watcher_recorded_change_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t full_path;
		type_info_member_t old_filename;
		type_info_member_t changes;
		type_info_member_t last_change_timestamp;
	}members;
};

struct type_info_file_watcher_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_valid;
		type_info_member_t is_verbose;
		type_info_member_t watcher_arena;
		type_info_member_t callback;
		type_info_member_t events_to_monitor;
		type_info_member_t user_data;
		type_info_member_t watch_recursively;
		type_info_member_t observed_changes;
		type_info_member_t change_count;
		type_info_member_t paths_to_watch;
		type_info_member_t paths_watched;
		type_info_member_t notify_buffer_size;
		type_info_member_t sys_watch_data;
		type_info_member_t issues_when_checking;
	}members;
};

struct type_info_global_context_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_initialized;
		type_info_member_t running;
		type_info_member_t context_arena;
		type_info_member_t temporary_arena;
		type_info_member_t main_threadpool;
	}members;
};

struct type_info_hash_table_header_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t max_entries;
		type_info_member_t flags;
		type_info_member_t current_entry_count;
		type_info_member_t debug_id;
	}members;
};

struct type_info_program_flag_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t bool32;
		type_info_member_t u64;
		type_info_member_t float32;
		type_info_member_t string;
	}members;
};

struct type_info_program_flag_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_valid;
		type_info_member_t name;
		type_info_member_t description;
		type_info_member_t arg_type;
		type_info_member_t arg_value;
		type_info_member_t default_arg_value;
	}members;
};

struct type_info_program_flag_state_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t program_flags;
		type_info_member_t flag_counter;
	}members;
};

struct type_info_string_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t data;
		type_info_member_t count;
	}members;
};

struct type_info_string_builder_buffer_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t buffer_data;
		type_info_member_t bytes_used;
		type_info_member_t buffer_size;
		type_info_member_t next_buffer;
	}members;
};

struct type_info_string_builder_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_initialized;
		type_info_member_t arena;
		type_info_member_t first_buffer;
		type_info_member_t current_buffer;
		type_info_member_t default_buffer_block_size;
		type_info_member_t bytes_used;
		type_info_member_t total_allocated;
	}members;
};

struct type_info_sys_thread_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t handle;
		type_info_member_t thread_id;
		type_info_member_t user_data;
	}members;
};

struct type_info_sys_mutex_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t handle;
	}members;
};

struct type_info_sys_semaphore_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t handle;
	}members;
};

struct type_info_threadpool_queue_entry_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_valid;
		type_info_member_t entry_buffer;
		type_info_member_t user_data;
		type_info_member_t callback;
	}members;
};

struct type_info_threadpool_queue_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t completion_goal;
		type_info_member_t entries_completed;
		type_info_member_t next_entry_to_write;
		type_info_member_t next_entry_to_read;
		type_info_member_t entries;
	}members;
};

struct type_info_threadpool_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_initialized;
		type_info_member_t semaphore;
		type_info_member_t threads_awake;
		type_info_member_t max_threads;
		type_info_member_t high_priority_queue;
		type_info_member_t low_priority_queue;
	}members;
};

struct type_info_zone_allocator_block_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t block_id;
		type_info_member_t is_allocated;
		type_info_member_t block_size;
		type_info_member_t allocation_tag;
		type_info_member_t next_block;
		type_info_member_t prev_block;
	}members;
};

struct type_info_zone_allocator_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t mutex;
		type_info_member_t capacity;
		type_info_member_t base;
		type_info_member_t first_block;
		type_info_member_t cursor;
	}members;
};

struct type_info_entity_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t e_type;
		type_info_member_t e_flags;
		type_info_member_t owner_client_id;
		type_info_member_t last_position;
		type_info_member_t position;
		type_info_member_t velocity;
	}members;
};

struct type_info_entity_manager_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t entities;
		type_info_member_t active_entities;
	}members;
};

struct type_info_input_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t input_axis;
	}members;
};

struct type_info_client_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t ID;
		type_info_member_t connected;
		type_info_member_t address;
		type_info_member_t addr_len;
		type_info_member_t player;
		type_info_member_t input_data_buffer;
		type_info_member_t input_data_head;
		type_info_member_t input_data_tail;
	}members;
};

struct type_info_game_state_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t window;
		type_info_member_t window_size;
		type_info_member_t input_axis;
		type_info_member_t entity_manager;
		type_info_member_t player;
		type_info_member_t is_host;
		type_info_member_t socket;
		type_info_member_t host_address_data;
		type_info_member_t client_id;
		type_info_member_t clients;
		type_info_member_t connected_client_count;
	}members;
};

struct type_info_render_geometry_instance_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t transform;
		type_info_member_t color;
		type_info_member_t uv_min;
		type_info_member_t uv_max;
		type_info_member_t texture_index;
		type_info_member_t camera_index;
	}members;
};

struct type_info_render_geometry_batch_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t camera_data;
		type_info_member_t is_valid;
		type_info_member_t primitive_count;
		type_info_member_t master_array_start_offset;
		type_info_member_t instances;
		type_info_member_t next_buffer;
	}members;
};

struct type_info_render_group_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t ID;
		type_info_member_t dynamic_pipeline_state;
		type_info_member_t shader;
		type_info_member_t textures;
		type_info_member_t current_texture_count;
		type_info_member_t master_batch_array;
		type_info_member_t total_primitive_count;
		type_info_member_t cached_buffer;
		type_info_member_t first_buffer;
	}members;
};

struct type_info_draw_frame_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t used_render_groups;
		type_info_member_t used_render_group_count;
		type_info_member_t used_camera;
		type_info_member_t used_camera_count;
		type_info_member_t cached_camera_ID;
		type_info_member_t active_render_layer;
		type_info_member_t active_render_group;
		type_info_member_t active_camera;
		type_info_member_t active_shader;
		type_info_member_t active_pipeline_state;
	}members;
};

struct type_info_render_state_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_initialized;
		type_info_member_t renderer_arena;
		type_info_member_t render_context;
		type_info_member_t current_frame_data;
		type_info_member_t render_group_hash;
		type_info_member_t draw_frame;
	}members;
};

struct type_info_global_matrix_uniforms_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t view_matrix;
		type_info_member_t projection_matrix;
	}members;
};

struct type_info_push_constant_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t DrawColor;
	}members;
};

struct type_info_render_camera_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t view_matrix;
		type_info_member_t projection_matrix;
		type_info_member_t ID;
	}members;
};

struct type_info_vulkan_buffer_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_valid;
		type_info_member_t is_mapped;
		type_info_member_t buffer_size;
		type_info_member_t handle;
		type_info_member_t device_memory;
		type_info_member_t usage_flags;
		type_info_member_t memory_index;
		type_info_member_t memory_property_flags;
	}members;
};

struct type_info_vulkan_pipeline_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t handle;
		type_info_member_t binding;
		type_info_member_t layout;
	}members;
};

struct type_info_render_pipeline_state_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t blend_enabled;
		type_info_member_t src_color_blend_mode;
		type_info_member_t dst_color_blend_mode;
		type_info_member_t src_alpha_blend_mode;
		type_info_member_t dst_alpha_blend_mode;
		type_info_member_t color_blend_op;
		type_info_member_t alpha_blend_op;
		type_info_member_t depth_testing_enabled;
		type_info_member_t depth_writing_enabled;
		type_info_member_t depth_func;
		type_info_member_t stencil_enabled;
		type_info_member_t stencil_state;
		type_info_member_t stencil_keep;
	}members;
};

struct type_info_spv_vulkan_type_map_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t spv_type;
		type_info_member_t vk_type;
	}members;
};

struct type_info_vulkan_shader_descriptor_set_info_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_valid;
		type_info_member_t set_type;
		type_info_member_t bindings;
		type_info_member_t binding_count;
		type_info_member_t binding_upload_size;
		type_info_member_t image_views;
		type_info_member_t samplers;
		type_info_member_t image_count;
		type_info_member_t sampler_count;
		type_info_member_t sets;
		type_info_member_t uniform_buffer;
		type_info_member_t single_frame_uniform_buffer_size;
	}members;
};

struct type_info_vulkan_shader_uniform_texture_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t image_views;
		type_info_member_t image_samplers;
		type_info_member_t image_counter;
	}members;
};

struct type_info_vulkan_shader_uniform_data_range_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t data;
		type_info_member_t data_size;
	}members;
};

struct type_info_vulkan_shader_uniform_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t owner_shader_id;
		type_info_member_t uniform_type;
		type_info_member_t set_type;
		type_info_member_t uniform_location;
		type_info_member_t push_constant_index;
		type_info_member_t name;
		type_info_member_t uniform_size;
		type_info_member_t is_texture;
		type_info_member_t mapped_buffer_update_size;
		type_info_member_t mapped_uniform_buffer;
		type_info_member_t storage_buffer;
	}members;
};

struct type_info_vulkan_shader_stage_info_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t type;
		type_info_member_t entry_point;
		type_info_member_t module_create_info;
		type_info_member_t shader_stage_create_info;
		type_info_member_t handle;
	}members;
};

struct type_info_vulkan_shader_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t shader_id;
		type_info_member_t name;
		type_info_member_t arena;
		type_info_member_t spv_reflect_module;
		type_info_member_t stages;
		type_info_member_t stage_count;
		type_info_member_t primary_pool;
		type_info_member_t type_counts;
		type_info_member_t layouts;
		type_info_member_t total_descriptor_set_count;
		type_info_member_t used_descriptor_set_count;
		type_info_member_t set_info;
		type_info_member_t push_constant_count;
		type_info_member_t push_constant_data;
		type_info_member_t uniforms;
		type_info_member_t uniform_count;
		type_info_member_t static_uniforms;
		type_info_member_t static_uniform_count;
		type_info_member_t draw_uniforms;
		type_info_member_t draw_uniform_count;
		type_info_member_t instance_uniforms;
		type_info_member_t instance_uniform_count;
		type_info_member_t pipeline;
		type_info_member_t camera_matrices;
	}members;
};

struct type_info_vulkan_physical_device_swapchain_support_info_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t surface_capabilities;
		type_info_member_t valid_surface_formats;
		type_info_member_t valid_present_modes;
		type_info_member_t valid_surface_format_count;
		type_info_member_t valid_present_mode_count;
	}members;
};

struct type_info_vulkan_physical_device_queue_info_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t graphics_queue_family_index;
		type_info_member_t present_queue_family_index;
		type_info_member_t compute_queue_family_index;
		type_info_member_t transfer_queue_family_index;
	}members;
};

struct type_info_vulkan_physical_device_requirements_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t has_graphics_queue;
		type_info_member_t has_present_queue;
		type_info_member_t has_transfer_queue;
		type_info_member_t has_compute_queue;
		type_info_member_t required_extensions;
	}members;
};

struct type_info_vulkan_physical_device_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t handle;
		type_info_member_t device_depth_format;
		type_info_member_t properties;
		type_info_member_t features;
		type_info_member_t memory_properties;
		type_info_member_t swapchain_support_info;
	}members;
};

struct type_info_vulkan_rendering_device_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t physical_device;
		type_info_member_t graphics_queue_family_index;
		type_info_member_t present_queue_family_index;
		type_info_member_t compute_queue_family_index;
		type_info_member_t transfer_queue_family_index;
		type_info_member_t graphics_queue;
		type_info_member_t present_queue;
		type_info_member_t transfer_queue;
		type_info_member_t compute_queue;
		type_info_member_t graphics_command_pool;
		type_info_member_t logical_device;
	}members;
};

struct type_info_vulkan_fence_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t handle;
		type_info_member_t signaled;
	}members;
};

struct type_info_vulkan_renderpass_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t handle;
		type_info_member_t offset;
		type_info_member_t size;
		type_info_member_t clear_color;
		type_info_member_t depth_clear;
		type_info_member_t stencil_clear;
		type_info_member_t renderpass_state;
	}members;
};

struct type_info_vulkan_framebuffer_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t handle;
		type_info_member_t renderpass;
		type_info_member_t attachments;
		type_info_member_t attachment_count;
	}members;
};

struct type_info_vulkan_image_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t handle;
		type_info_member_t memory;
		type_info_member_t format;
		type_info_member_t layout;
		type_info_member_t view;
		type_info_member_t width;
		type_info_member_t height;
	}members;
};

struct type_info_vulkan_texture_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t current_generation;
		type_info_member_t image_data;
		type_info_member_t sampler;
	}members;
};

struct type_info_vulkan_swapchain_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_valid;
		type_info_member_t arena;
		type_info_member_t handle;
		type_info_member_t image_format;
		type_info_member_t present_mode;
		type_info_member_t depth_attachment;
		type_info_member_t has_depth_attachment;
		type_info_member_t max_frames_in_flight;
		type_info_member_t image_count;
		type_info_member_t framebuffers;
		type_info_member_t images;
		type_info_member_t views;
	}members;
};

struct type_info_vulkan_command_buffer_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t handle;
		type_info_member_t owner_pool;
		type_info_member_t state;
		type_info_member_t is_primary_buffer;
		type_info_member_t is_single_use;
	}members;
};

struct type_info_vulkan_render_backend_function_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t create_gpu_texture;
		type_info_member_t create_gpu_shader;
		type_info_member_t create_gpu_buffer;
		type_info_member_t destroy_gpu_texture;
		type_info_member_t destroy_gpu_shader;
		type_info_member_t destroy_gpu_buffer;
	}members;
};

struct type_info_vulkan_render_frame_state_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t image_render_idle_fence;
		type_info_member_t frame_in_flight_fence_ptr;
		type_info_member_t image_avaliable_semaphore;
		type_info_member_t presentation_complete_semaphore;
		type_info_member_t current_framebuffer;
		type_info_member_t render_command_buffer;
		type_info_member_t instanced_rendering_buffer;
		type_info_member_t bound_shader;
	}members;
};

struct type_info_vulkan_render_context_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t initialization_arena;
		type_info_member_t frame_arena;
		type_info_member_t permanent_arena;
		type_info_member_t additional_buffer_count;
		type_info_member_t window;
		type_info_member_t window_width;
		type_info_member_t window_height;
		type_info_member_t instance;
		type_info_member_t allocators;
		type_info_member_t render_surface;
		type_info_member_t rendering_device;
		type_info_member_t swapchain;
		type_info_member_t current_image_index;
		type_info_member_t current_frame_index;
		type_info_member_t framebuffer_width;
		type_info_member_t framebuffer_height;
		type_info_member_t cached_framebuffer_width;
		type_info_member_t cached_framebuffer_height;
		type_info_member_t current_framebuffer_size_generation;
		type_info_member_t last_framebuffer_size_generation;
		type_info_member_t recreating_swapchain;
		type_info_member_t image_render_idle_fences;
		type_info_member_t frame_in_flight_fence_ptrs;
		type_info_member_t image_avaliable_semaphores;
		type_info_member_t presentation_complete_semaphores;
		type_info_member_t render_command_buffers;
		type_info_member_t frames;
		type_info_member_t current_frame;
		type_info_member_t instanced_rendering_buffer;
		type_info_member_t index_buffer;
		type_info_member_t vertex_buffer;
		type_info_member_t main_renderpass;
		type_info_member_t default_shader;
		type_info_member_t default_texture;
		type_info_member_t invalid_texture_data;
		type_info_member_t vertex_offset;
		type_info_member_t geometry_index;
		type_info_member_t test_camera;
		type_info_member_t debug_callback;
	}members;
};

struct type_info_asset_handle_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_valid;
		type_info_member_t type;
		type_info_member_t owner_asset_file_index;
		type_info_member_t subtexture_data;
		type_info_member_t slot;
	}members;
};

struct type_info_bitmap_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t width;
		type_info_member_t height;
		type_info_member_t channels;
		type_info_member_t format;
		type_info_member_t pixels;
	}members;
};

struct type_info_texture2D_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t bitmap;
		type_info_member_t gpu_data;
	}members;
};

struct type_info_subtexture_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t uv_min;
		type_info_member_t uv_max;
		type_info_member_t offset;
		type_info_member_t size;
		type_info_member_t atlas_subtexture_index;
		type_info_member_t atlas;
	}members;
};

struct type_info_texture_atlas_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t texture;
		type_info_member_t bitmap_data;
		type_info_member_t ID;
		type_info_member_t merge_counter;
		type_info_member_t textures_to_merge;
		type_info_member_t packed_subtextures;
		type_info_member_t packed_subtexture_count;
		type_info_member_t is_valid;
		type_info_member_t atlas_cursor_x;
		type_info_member_t atlas_cursor_y;
		type_info_member_t tallest_y;
		type_info_member_t atlas_size;
	}members;
};

struct type_info_shader_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t ID;
		type_info_member_t shader_data;
		type_info_member_t camera_uniform;
		type_info_member_t texture_uniform;
	}members;
};

struct type_info_material_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t ID;
		type_info_member_t name;
		type_info_member_t shader;
		type_info_member_t diffuse_map;
		type_info_member_t normal_map;
		type_info_member_t pipeline_state;
	}members;
};

struct type_info_asset_slot_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t slot_state;
		type_info_member_t type;
		type_info_member_t name;
		type_info_member_t owner_asset_file;
		type_info_member_t package_entry;
		type_info_member_t package_generation;
		type_info_member_t ref_counter;
		type_info_member_t texture;
		type_info_member_t shader;
		type_info_member_t material;
	}members;
};

struct type_info_asset_manager_asset_file_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_initialized;
		type_info_member_t ID;
		type_info_member_t init_arena;
		type_info_member_t load_status;
		type_info_member_t file_info;
		type_info_member_t raw_file_data;
		type_info_member_t package_entries;
		type_info_member_t package_entry_count;
		type_info_member_t entry_hash;
		type_info_member_t header_data;
	}members;
};

struct type_info_asset_catalog_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t ID;
		type_info_member_t catalog_type;
		type_info_member_t asset_manager;
		type_info_member_t asset_lookup;
	}members;
};

struct type_info_texture_atlas_registry_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t atlases;
		type_info_member_t current_atlas_count;
	}members;
};

struct type_info_asset_manager_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_initialized;
		type_info_member_t manager_arena;
		type_info_member_t asset_files;
		type_info_member_t asset_name_to_file;
		type_info_member_t loaded_file_count;
		type_info_member_t asset_load_queue;
		type_info_member_t asset_unload_queue;
		type_info_member_t atlas_registry;
		type_info_member_t asset_allocator;
		type_info_member_t asset_catalogs;
		type_info_member_t texture_catalog;
		type_info_member_t shader_catalog;
		type_info_member_t render_context;
	}members;
};

struct type_info_action_button_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_down;
		type_info_member_t is_released;
		type_info_member_t is_pressed;
		type_info_member_t half_transition_counter;
	}members;
};

struct type_info_keyboard_controller_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t input;
		type_info_member_t current_mouse_pos;
		type_info_member_t last_mouse_pos;
		type_info_member_t mouse_delta;
		type_info_member_t is_shift_key_down;
		type_info_member_t is_control_key_down;
		type_info_member_t is_alt_key_down;
	}members;
};

struct type_info_analog_button_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t deadzone;
		type_info_member_t value;
	}members;
};

struct type_info_gamepad_controller_data_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t gamepad_data;
		type_info_member_t stick_data;
		type_info_member_t gamepad_id;
		type_info_member_t has_rumble;
		type_info_member_t rumble_value;
		type_info_member_t digital_buttons;
		type_info_member_t analog_buttons;
	}members;
};

struct type_info_input_controller_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t is_valid;
		type_info_member_t is_analog;
		type_info_member_t type;
		type_info_member_t keyboard;
		type_info_member_t gamepad;
	}members;
};

struct type_info_game_action_binding_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t type;
		type_info_member_t binding_id;
	}members;
};

struct type_info_game_action_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t keyboard;
		type_info_member_t gamepad;
		type_info_member_t name;
	}members;
};

struct type_info_input_manager_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t keyboard_data;
		type_info_member_t gamepad_data;
		type_info_member_t primary_controller_index;
		type_info_member_t active_controller_index;
		type_info_member_t connected_controller_count;
		type_info_member_t controllers;
		type_info_member_t game_actions;
	}members;
};

struct type_info_packet_t {
	const char *name;
	u32 type;
	u32 member_count;
	struct {
		type_info_member_t magic_value;
		type_info_member_t type;
		type_info_member_t client_id;
		type_info_member_t input_data;
	}members;
};


const static type_info_memory_arena_footer_t type_info_memory_arena_footer_t = {
	.name = "memory_arena_footer_t",
	.type = TYPE_memory_arena_footer_t,
	.member_count = 3,
	.members = {
		.last_base = {.name = "last_base", .type = TYPE_byte, .offset = offsetof(memory_arena_footer_t, last_base), .size = sizeof(byte*)},
		.last_used = {.name = "last_used", .type = TYPE_u64, .offset = offsetof(memory_arena_footer_t, last_used), .size = sizeof(u64)},
		.last_block_size = {.name = "last_block_size", .type = TYPE_u64, .offset = offsetof(memory_arena_footer_t, last_block_size), .size = sizeof(u64)},
	}
};

const static type_info_memory_arena_t type_info_memory_arena_t = {
	.name = "memory_arena_t",
	.type = TYPE_memory_arena_t,
	.member_count = 6,
	.members = {
		.is_initialized = {.name = "is_initialized", .type = TYPE_bool32, .offset = offsetof(memory_arena_t, is_initialized), .size = sizeof(bool32)},
		.base = {.name = "base", .type = TYPE_byte, .offset = offsetof(memory_arena_t, base), .size = sizeof(byte*)},
		.used = {.name = "used", .type = TYPE_u64, .offset = offsetof(memory_arena_t, used), .size = sizeof(u64)},
		.block_size = {.name = "block_size", .type = TYPE_u64, .offset = offsetof(memory_arena_t, block_size), .size = sizeof(u64)},
		.block_counter = {.name = "block_counter", .type = TYPE_u32, .offset = offsetof(memory_arena_t, block_counter), .size = sizeof(u32)},
		.scratch_arena_count = {.name = "scratch_arena_count", .type = TYPE_u32, .offset = offsetof(memory_arena_t, scratch_arena_count), .size = sizeof(u32)},
	}
};

const static type_info_scratch_arena_t type_info_scratch_arena_t = {
	.name = "scratch_arena_t",
	.type = TYPE_scratch_arena_t,
	.member_count = 3,
	.members = {
		.parent = {.name = "parent", .type = TYPE_memory_arena_t, .offset = offsetof(scratch_arena_t, parent), .size = sizeof(memory_arena_t*)},
		.base = {.name = "base", .type = TYPE_u8, .offset = offsetof(scratch_arena_t, base), .size = sizeof(u8*)},
		.used = {.name = "used", .type = TYPE_u64, .offset = offsetof(scratch_arena_t, used), .size = sizeof(u64)},
	}
};

const static type_info_dynarray_header_t type_info_dynarray_header_t = {
	.name = "dynarray_header_t",
	.type = TYPE_dynarray_header_t,
	.member_count = 4,
	.members = {
		.flags = {.name = "flags", .type = TYPE_u32, .offset = offsetof(dynarray_header_t, flags), .size = sizeof(u32)},
		.size = {.name = "size", .type = TYPE_u32, .offset = offsetof(dynarray_header_t, size), .size = sizeof(u32)},
		.capacity = {.name = "capacity", .type = TYPE_u32, .offset = offsetof(dynarray_header_t, capacity), .size = sizeof(u32)},
		.header_id = {.name = "header_id", .type = TYPE_u32, .offset = offsetof(dynarray_header_t, header_id), .size = sizeof(u32)},
	}
};

const static type_info_file_t type_info_file_t = {
	.name = "file_t",
	.type = TYPE_file_t,
	.member_count = 8,
	.members = {
		.handle = {.name = "handle", .type = TYPE_sys_handle_t, .offset = offsetof(file_t, handle), .size = sizeof(sys_handle_t)},
		.file_name = {.name = "file_name", .type = TYPE_string_t, .offset = offsetof(file_t, file_name), .size = sizeof(string_t)},
		.filepath = {.name = "filepath", .type = TYPE_string_t, .offset = offsetof(file_t, filepath), .size = sizeof(string_t)},
		.file_size = {.name = "file_size", .type = TYPE_u64, .offset = offsetof(file_t, file_size), .size = sizeof(u64)},
		.current_read_offset = {.name = "current_read_offset", .type = TYPE_u64, .offset = offsetof(file_t, current_read_offset), .size = sizeof(u64)},
		.current_write_offset = {.name = "current_write_offset", .type = TYPE_u64, .offset = offsetof(file_t, current_write_offset), .size = sizeof(u64)},
		.overlapping = {.name = "overlapping", .type = TYPE_bool8, .offset = offsetof(file_t, overlapping), .size = sizeof(bool8)},
		.for_writing = {.name = "for_writing", .type = TYPE_bool8, .offset = offsetof(file_t, for_writing), .size = sizeof(bool8)},
	}
};

const static type_info_mapped_file_t type_info_mapped_file_t = {
	.name = "mapped_file_t",
	.type = TYPE_mapped_file_t,
	.member_count = 3,
	.members = {
		.file = {.name = "file", .type = TYPE_file_t, .offset = offsetof(mapped_file_t, file), .size = sizeof(file_t)},
		.mapping_handle = {.name = "mapping_handle", .type = TYPE_sys_handle_t, .offset = offsetof(mapped_file_t, mapping_handle), .size = sizeof(sys_handle_t)},
		.mapped_file_data = {.name = "mapped_file_data", .type = TYPE_string_t, .offset = offsetof(mapped_file_t, mapped_file_data), .size = sizeof(string_t)},
	}
};

const static type_info_file_data_t type_info_file_data_t = {
	.name = "file_data_t",
	.type = TYPE_file_data_t,
	.member_count = 4,
	.members = {
		.last_modtime = {.name = "last_modtime", .type = TYPE_u64, .offset = offsetof(file_data_t, last_modtime), .size = sizeof(u64)},
		.file_size = {.name = "file_size", .type = TYPE_u64, .offset = offsetof(file_data_t, file_size), .size = sizeof(u64)},
		.filename = {.name = "filename", .type = TYPE_string_t, .offset = offsetof(file_data_t, filename), .size = sizeof(string_t)},
		.filepath = {.name = "filepath", .type = TYPE_string_t, .offset = offsetof(file_data_t, filepath), .size = sizeof(string_t)},
	}
};

const static type_info_overlap_io_data_t type_info_overlap_io_data_t = {
	.name = "overlap_io_data_t",
	.type = TYPE_overlap_io_data_t,
	.member_count = 5,
	.members = {
		.offset_to_read = {.name = "offset_to_read", .type = TYPE_u64, .offset = offsetof(overlap_io_data_t, offset_to_read), .size = sizeof(u64)},
		.bytes_to_read = {.name = "bytes_to_read", .type = TYPE_u64, .offset = offsetof(overlap_io_data_t, bytes_to_read), .size = sizeof(u64)},
		.status = {.name = "status", .type = TYPE_u32, .offset = offsetof(overlap_io_data_t, status), .size = sizeof(u32)},
		.bytes_transfered = {.name = "bytes_transfered", .type = TYPE_u32, .offset = offsetof(overlap_io_data_t, bytes_transfered), .size = sizeof(u32)},
		.event_handle = {.name = "event_handle", .type = TYPE_sys_handle_t, .offset = offsetof(overlap_io_data_t, event_handle), .size = sizeof(sys_handle_t)},
	}
};

const static type_info_visit_file_data_t type_info_visit_file_data_t = {
	.name = "visit_file_data_t",
	.type = TYPE_visit_file_data_t,
	.member_count = 6,
	.members = {
		.function = {.name = "function", .type = TYPE_visit_files_pfn_t, .offset = offsetof(visit_file_data_t, function), .size = sizeof(visit_files_pfn_t*)},
		.user_data = {.name = "user_data", .type = TYPE_void, .offset = offsetof(visit_file_data_t, user_data), .size = sizeof(void*)},
		.filename = {.name = "filename", .type = TYPE_string_t, .offset = offsetof(visit_file_data_t, filename), .size = sizeof(string_t)},
		.fullname = {.name = "fullname", .type = TYPE_string_t, .offset = offsetof(visit_file_data_t, fullname), .size = sizeof(string_t)},
		.recursive = {.name = "recursive", .type = TYPE_bool8, .offset = offsetof(visit_file_data_t, recursive), .size = sizeof(bool8)},
		.is_directory = {.name = "is_directory", .type = TYPE_bool8, .offset = offsetof(visit_file_data_t, is_directory), .size = sizeof(bool8)},
	}
};

const static type_info_file_watcher_recorded_change_t type_info_file_watcher_recorded_change_t = {
	.name = "file_watcher_recorded_change_t",
	.type = TYPE_file_watcher_recorded_change_t,
	.member_count = 4,
	.members = {
		.full_path = {.name = "full_path", .type = TYPE_string_t, .offset = offsetof(file_watcher_recorded_change_t, full_path), .size = sizeof(string_t)},
		.old_filename = {.name = "old_filename", .type = TYPE_string_t, .offset = offsetof(file_watcher_recorded_change_t, old_filename), .size = sizeof(string_t)},
		.changes = {.name = "changes", .type = TYPE_u32, .offset = offsetof(file_watcher_recorded_change_t, changes), .size = sizeof(u32)},
		.last_change_timestamp = {.name = "last_change_timestamp", .type = TYPE_u64, .offset = offsetof(file_watcher_recorded_change_t, last_change_timestamp), .size = sizeof(u64)},
	}
};

const static type_info_file_watcher_t type_info_file_watcher_t = {
	.name = "file_watcher_t",
	.type = TYPE_file_watcher_t,
	.member_count = 14,
	.members = {
		.is_valid = {.name = "is_valid", .type = TYPE_bool8, .offset = offsetof(file_watcher_t, is_valid), .size = sizeof(bool8)},
		.is_verbose = {.name = "is_verbose", .type = TYPE_bool8, .offset = offsetof(file_watcher_t, is_verbose), .size = sizeof(bool8)},
		.watcher_arena = {.name = "watcher_arena", .type = TYPE_memory_arena_t, .offset = offsetof(file_watcher_t, watcher_arena), .size = sizeof(memory_arena_t)},
		.callback = {.name = "callback", .type = TYPE_file_watcher_callback_pfn_t, .offset = offsetof(file_watcher_t, callback), .size = sizeof(file_watcher_callback_pfn_t*)},
		.events_to_monitor = {.name = "events_to_monitor", .type = TYPE_file_watcher_change_event_t, .offset = offsetof(file_watcher_t, events_to_monitor), .size = sizeof(file_watcher_change_event_t)},
		.user_data = {.name = "user_data", .type = TYPE_void, .offset = offsetof(file_watcher_t, user_data), .size = sizeof(void*)},
		.watch_recursively = {.name = "watch_recursively", .type = TYPE_bool8, .offset = offsetof(file_watcher_t, watch_recursively), .size = sizeof(bool8)},
		.observed_changes = {.name = "observed_changes", .type = TYPE_file_watcher_recorded_change_t, .offset = offsetof(file_watcher_t, observed_changes), .size = sizeof(file_watcher_recorded_change_t)},
		.change_count = {.name = "change_count", .type = TYPE_u32, .offset = offsetof(file_watcher_t, change_count), .size = sizeof(u32)},
		.paths_to_watch = {.name = "paths_to_watch", .type = TYPE_string_t, .offset = offsetof(file_watcher_t, paths_to_watch), .size = sizeof(string_t)},
		.paths_watched = {.name = "paths_watched", .type = TYPE_u32, .offset = offsetof(file_watcher_t, paths_watched), .size = sizeof(u32)},
		.notify_buffer_size = {.name = "notify_buffer_size", .type = TYPE_u32, .offset = offsetof(file_watcher_t, notify_buffer_size), .size = sizeof(u32)},
		.sys_watch_data = {.name = "sys_watch_data", .type = TYPE_file_watcher_sys_watch_data_t, .offset = offsetof(file_watcher_t, sys_watch_data), .size = sizeof(file_watcher_sys_watch_data_t)},
		.issues_when_checking = {.name = "issues_when_checking", .type = TYPE_bool8, .offset = offsetof(file_watcher_t, issues_when_checking), .size = sizeof(bool8)},
	}
};

const static type_info_global_context_t type_info_global_context_t = {
	.name = "global_context_t",
	.type = TYPE_global_context_t,
	.member_count = 5,
	.members = {
		.is_initialized = {.name = "is_initialized", .type = TYPE_bool8, .offset = offsetof(global_context_t, is_initialized), .size = sizeof(bool8)},
		.running = {.name = "running", .type = TYPE_bool8, .offset = offsetof(global_context_t, running), .size = sizeof(bool8)},
		.context_arena = {.name = "context_arena", .type = TYPE_memory_arena_t, .offset = offsetof(global_context_t, context_arena), .size = sizeof(memory_arena_t)},
		.temporary_arena = {.name = "temporary_arena", .type = TYPE_memory_arena_t, .offset = offsetof(global_context_t, temporary_arena), .size = sizeof(memory_arena_t)},
		.main_threadpool = {.name = "main_threadpool", .type = TYPE_threadpool_t, .offset = offsetof(global_context_t, main_threadpool), .size = sizeof(threadpool_t)},
	}
};

const static type_info_hash_table_header_t type_info_hash_table_header_t = {
	.name = "hash_table_header_t",
	.type = TYPE_hash_table_header_t,
	.member_count = 4,
	.members = {
		.max_entries = {.name = "max_entries", .type = TYPE_u32, .offset = offsetof(hash_table_header_t, max_entries), .size = sizeof(u32)},
		.flags = {.name = "flags", .type = TYPE_u32, .offset = offsetof(hash_table_header_t, flags), .size = sizeof(u32)},
		.current_entry_count = {.name = "current_entry_count", .type = TYPE_u32, .offset = offsetof(hash_table_header_t, current_entry_count), .size = sizeof(u32)},
		.debug_id = {.name = "debug_id", .type = TYPE_u32, .offset = offsetof(hash_table_header_t, debug_id), .size = sizeof(u32)},
	}
};

const static type_info_program_flag_data_t type_info_program_flag_data_t = {
	.name = "program_flag_data_t",
	.type = TYPE_program_flag_data_t,
	.member_count = 4,
	.members = {
		.bool32 = {.name = "bool32", .type = TYPE_bool32, .offset = offsetof(program_flag_data_t, bool32), .size = sizeof(bool32)},
		.u64 = {.name = "u64", .type = TYPE_u64, .offset = offsetof(program_flag_data_t, u64), .size = sizeof(u64)},
		.float32 = {.name = "float32", .type = TYPE_float32, .offset = offsetof(program_flag_data_t, float32), .size = sizeof(float32)},
		.string = {.name = "string", .type = TYPE_char, .offset = offsetof(program_flag_data_t, string), .size = sizeof(char*)},
	}
};

const static type_info_program_flag_t type_info_program_flag_t = {
	.name = "program_flag_t",
	.type = TYPE_program_flag_t,
	.member_count = 6,
	.members = {
		.is_valid = {.name = "is_valid", .type = TYPE_bool8, .offset = offsetof(program_flag_t, is_valid), .size = sizeof(bool8)},
		.name = {.name = "name", .type = TYPE_char, .offset = offsetof(program_flag_t, name), .size = sizeof(char*)},
		.description = {.name = "description", .type = TYPE_char, .offset = offsetof(program_flag_t, description), .size = sizeof(char*)},
		.arg_type = {.name = "arg_type", .type = TYPE_arg_type_t, .offset = offsetof(program_flag_t, arg_type), .size = sizeof(arg_type_t)},
		.arg_value = {.name = "arg_value", .type = TYPE_program_flag_data_t, .offset = offsetof(program_flag_t, arg_value), .size = sizeof(program_flag_data_t)},
		.default_arg_value = {.name = "default_arg_value", .type = TYPE_program_flag_data_t, .offset = offsetof(program_flag_t, default_arg_value), .size = sizeof(program_flag_data_t)},
	}
};

const static type_info_program_flag_state_t type_info_program_flag_state_t = {
	.name = "program_flag_state_t",
	.type = TYPE_program_flag_state_t,
	.member_count = 2,
	.members = {
		.program_flags = {.name = "program_flags", .type = TYPE_program_flag_t, .offset = offsetof(program_flag_state_t, program_flags), .size = sizeof(program_flag_t)},
		.flag_counter = {.name = "flag_counter", .type = TYPE_u32, .offset = offsetof(program_flag_state_t, flag_counter), .size = sizeof(u32)},
	}
};

const static type_info_string_t type_info_string_t = {
	.name = "string_t",
	.type = TYPE_string_t,
	.member_count = 2,
	.members = {
		.data = {.name = "data", .type = TYPE_byte, .offset = offsetof(string_t, data), .size = sizeof(byte*)},
		.count = {.name = "count", .type = TYPE_u32, .offset = offsetof(string_t, count), .size = sizeof(u32)},
	}
};

const static type_info_string_builder_buffer_t type_info_string_builder_buffer_t = {
	.name = "string_builder_buffer_t",
	.type = TYPE_string_builder_buffer_t,
	.member_count = 4,
	.members = {
		.buffer_data = {.name = "buffer_data", .type = TYPE_byte, .offset = offsetof(string_builder_buffer_t, buffer_data), .size = sizeof(byte*)},
		.bytes_used = {.name = "bytes_used", .type = TYPE_u32, .offset = offsetof(string_builder_buffer_t, bytes_used), .size = sizeof(u32)},
		.buffer_size = {.name = "buffer_size", .type = TYPE_u32, .offset = offsetof(string_builder_buffer_t, buffer_size), .size = sizeof(u32)},
		.next_buffer = {.name = "next_buffer", .type = TYPE_string_builder_buffer_t, .offset = offsetof(string_builder_buffer_t, next_buffer), .size = sizeof(string_builder_buffer_t*)},
	}
};

const static type_info_string_builder_t type_info_string_builder_t = {
	.name = "string_builder_t",
	.type = TYPE_string_builder_t,
	.member_count = 7,
	.members = {
		.is_initialized = {.name = "is_initialized", .type = TYPE_bool8, .offset = offsetof(string_builder_t, is_initialized), .size = sizeof(bool8)},
		.arena = {.name = "arena", .type = TYPE_memory_arena_t, .offset = offsetof(string_builder_t, arena), .size = sizeof(memory_arena_t)},
		.first_buffer = {.name = "first_buffer", .type = TYPE_string_builder_buffer_t, .offset = offsetof(string_builder_t, first_buffer), .size = sizeof(string_builder_buffer_t*)},
		.current_buffer = {.name = "current_buffer", .type = TYPE_string_builder_buffer_t, .offset = offsetof(string_builder_t, current_buffer), .size = sizeof(string_builder_buffer_t*)},
		.default_buffer_block_size = {.name = "default_buffer_block_size", .type = TYPE_u64, .offset = offsetof(string_builder_t, default_buffer_block_size), .size = sizeof(u64)},
		.bytes_used = {.name = "bytes_used", .type = TYPE_u64, .offset = offsetof(string_builder_t, bytes_used), .size = sizeof(u64)},
		.total_allocated = {.name = "total_allocated", .type = TYPE_u64, .offset = offsetof(string_builder_t, total_allocated), .size = sizeof(u64)},
	}
};

const static type_info_sys_thread_t type_info_sys_thread_t = {
	.name = "sys_thread_t",
	.type = TYPE_sys_thread_t,
	.member_count = 3,
	.members = {
		.handle = {.name = "handle", .type = TYPE_sys_thread_handle_t, .offset = offsetof(sys_thread_t, handle), .size = sizeof(sys_thread_handle_t)},
		.thread_id = {.name = "thread_id", .type = TYPE_u32, .offset = offsetof(sys_thread_t, thread_id), .size = sizeof(u32)},
		.user_data = {.name = "user_data", .type = TYPE_void, .offset = offsetof(sys_thread_t, user_data), .size = sizeof(void*)},
	}
};

const static type_info_sys_mutex_t type_info_sys_mutex_t = {
	.name = "sys_mutex_t",
	.type = TYPE_sys_mutex_t,
	.member_count = 1,
	.members = {
		.handle = {.name = "handle", .type = TYPE_sys_mutex_handle_t, .offset = offsetof(sys_mutex_t, handle), .size = sizeof(sys_mutex_handle_t)},
	}
};

const static type_info_sys_semaphore_t type_info_sys_semaphore_t = {
	.name = "sys_semaphore_t",
	.type = TYPE_sys_semaphore_t,
	.member_count = 1,
	.members = {
		.handle = {.name = "handle", .type = TYPE_sys_semaphore_handle_t, .offset = offsetof(sys_semaphore_t, handle), .size = sizeof(sys_semaphore_handle_t)},
	}
};

const static type_info_threadpool_queue_entry_t type_info_threadpool_queue_entry_t = {
	.name = "threadpool_queue_entry_t",
	.type = TYPE_threadpool_queue_entry_t,
	.member_count = 4,
	.members = {
		.is_valid = {.name = "is_valid", .type = TYPE_bool8, .offset = offsetof(threadpool_queue_entry_t, is_valid), .size = sizeof(bool8)},
		.entry_buffer = {.name = "entry_buffer", .type = TYPE_byte, .offset = offsetof(threadpool_queue_entry_t, entry_buffer), .size = sizeof(byte)},
		.user_data = {.name = "user_data", .type = TYPE_void, .offset = offsetof(threadpool_queue_entry_t, user_data), .size = sizeof(void*)},
		.callback = {.name = "callback", .type = TYPE_threadpool_callback_t, .offset = offsetof(threadpool_queue_entry_t, callback), .size = sizeof(threadpool_callback_t*)},
	}
};

const static type_info_threadpool_queue_t type_info_threadpool_queue_t = {
	.name = "threadpool_queue_t",
	.type = TYPE_threadpool_queue_t,
	.member_count = 5,
	.members = {
		.completion_goal = {.name = "completion_goal", .type = TYPE_u32, .offset = offsetof(threadpool_queue_t, completion_goal), .size = sizeof(u32)},
		.entries_completed = {.name = "entries_completed", .type = TYPE_u32, .offset = offsetof(threadpool_queue_t, entries_completed), .size = sizeof(u32)},
		.next_entry_to_write = {.name = "next_entry_to_write", .type = TYPE_u32, .offset = offsetof(threadpool_queue_t, next_entry_to_write), .size = sizeof(u32)},
		.next_entry_to_read = {.name = "next_entry_to_read", .type = TYPE_u32, .offset = offsetof(threadpool_queue_t, next_entry_to_read), .size = sizeof(u32)},
		.entries = {.name = "entries", .type = TYPE_threadpool_queue_entry_t, .offset = offsetof(threadpool_queue_t, entries), .size = sizeof(threadpool_queue_entry_t)},
	}
};

const static type_info_threadpool_t type_info_threadpool_t = {
	.name = "threadpool_t",
	.type = TYPE_threadpool_t,
	.member_count = 6,
	.members = {
		.is_initialized = {.name = "is_initialized", .type = TYPE_bool8, .offset = offsetof(threadpool_t, is_initialized), .size = sizeof(bool8)},
		.semaphore = {.name = "semaphore", .type = TYPE_sys_semaphore_t, .offset = offsetof(threadpool_t, semaphore), .size = sizeof(sys_semaphore_t)},
		.threads_awake = {.name = "threads_awake", .type = TYPE_u32, .offset = offsetof(threadpool_t, threads_awake), .size = sizeof(u32)},
		.max_threads = {.name = "max_threads", .type = TYPE_u32, .offset = offsetof(threadpool_t, max_threads), .size = sizeof(u32)},
		.high_priority_queue = {.name = "high_priority_queue", .type = TYPE_threadpool_queue_t, .offset = offsetof(threadpool_t, high_priority_queue), .size = sizeof(threadpool_queue_t)},
		.low_priority_queue = {.name = "low_priority_queue", .type = TYPE_threadpool_queue_t, .offset = offsetof(threadpool_t, low_priority_queue), .size = sizeof(threadpool_queue_t)},
	}
};

const static type_info_zone_allocator_block_t type_info_zone_allocator_block_t = {
	.name = "zone_allocator_block_t",
	.type = TYPE_zone_allocator_block_t,
	.member_count = 6,
	.members = {
		.block_id = {.name = "block_id", .type = TYPE_u32, .offset = offsetof(zone_allocator_block_t, block_id), .size = sizeof(u32)},
		.is_allocated = {.name = "is_allocated", .type = TYPE_bool8, .offset = offsetof(zone_allocator_block_t, is_allocated), .size = sizeof(bool8)},
		.block_size = {.name = "block_size", .type = TYPE_u64, .offset = offsetof(zone_allocator_block_t, block_size), .size = sizeof(u64)},
		.allocation_tag = {.name = "allocation_tag", .type = TYPE_u64, .offset = offsetof(zone_allocator_block_t, allocation_tag), .size = sizeof(u64)},
		.next_block = {.name = "next_block", .type = TYPE_zone_allocator_block_t, .offset = offsetof(zone_allocator_block_t, next_block), .size = sizeof(zone_allocator_block_t*)},
		.prev_block = {.name = "prev_block", .type = TYPE_zone_allocator_block_t, .offset = offsetof(zone_allocator_block_t, prev_block), .size = sizeof(zone_allocator_block_t*)},
	}
};

const static type_info_zone_allocator_t type_info_zone_allocator_t = {
	.name = "zone_allocator_t",
	.type = TYPE_zone_allocator_t,
	.member_count = 5,
	.members = {
		.mutex = {.name = "mutex", .type = TYPE_sys_mutex_t, .offset = offsetof(zone_allocator_t, mutex), .size = sizeof(sys_mutex_t)},
		.capacity = {.name = "capacity", .type = TYPE_u64, .offset = offsetof(zone_allocator_t, capacity), .size = sizeof(u64)},
		.base = {.name = "base", .type = TYPE_u8, .offset = offsetof(zone_allocator_t, base), .size = sizeof(u8*)},
		.first_block = {.name = "first_block", .type = TYPE_zone_allocator_block_t, .offset = offsetof(zone_allocator_t, first_block), .size = sizeof(zone_allocator_block_t)},
		.cursor = {.name = "cursor", .type = TYPE_zone_allocator_block_t, .offset = offsetof(zone_allocator_t, cursor), .size = sizeof(zone_allocator_block_t*)},
	}
};

const static type_info_entity_t type_info_entity_t = {
	.name = "entity_t",
	.type = TYPE_entity_t,
	.member_count = 6,
	.members = {
		.e_type = {.name = "e_type", .type = TYPE_u32, .offset = offsetof(entity_t, e_type), .size = sizeof(u32)},
		.e_flags = {.name = "e_flags", .type = TYPE_u32, .offset = offsetof(entity_t, e_flags), .size = sizeof(u32)},
		.owner_client_id = {.name = "owner_client_id", .type = TYPE_u32, .offset = offsetof(entity_t, owner_client_id), .size = sizeof(u32)},
		.last_position = {.name = "last_position", .type = TYPE_vec2_t, .offset = offsetof(entity_t, last_position), .size = sizeof(vec2_t)},
		.position = {.name = "position", .type = TYPE_vec2_t, .offset = offsetof(entity_t, position), .size = sizeof(vec2_t)},
		.velocity = {.name = "velocity", .type = TYPE_vec2_t, .offset = offsetof(entity_t, velocity), .size = sizeof(vec2_t)},
	}
};

const static type_info_entity_manager_t type_info_entity_manager_t = {
	.name = "entity_manager_t",
	.type = TYPE_entity_manager_t,
	.member_count = 2,
	.members = {
		.entities = {.name = "entities", .type = TYPE_entity_t, .offset = offsetof(entity_manager_t, entities), .size = sizeof(entity_t)},
		.active_entities = {.name = "active_entities", .type = TYPE_u32, .offset = offsetof(entity_manager_t, active_entities), .size = sizeof(u32)},
	}
};

const static type_info_input_data_t type_info_input_data_t = {
	.name = "input_data_t",
	.type = TYPE_input_data_t,
	.member_count = 1,
	.members = {
		.input_axis = {.name = "input_axis", .type = TYPE_vec2_t, .offset = offsetof(input_data_t, input_axis), .size = sizeof(vec2_t)},
	}
};

const static type_info_client_data_t type_info_client_data_t = {
	.name = "client_data_t",
	.type = TYPE_client_data_t,
	.member_count = 8,
	.members = {
		.ID = {.name = "ID", .type = TYPE_u32, .offset = offsetof(client_data_t, ID), .size = sizeof(u32)},
		.connected = {.name = "connected", .type = TYPE_bool32, .offset = offsetof(client_data_t, connected), .size = sizeof(bool32)},
		.address = {.name = "address", .type = TYPE_sockaddr_storage, .offset = offsetof(client_data_t, address), .size = sizeof(sockaddr_storage)},
		.addr_len = {.name = "addr_len", .type = TYPE_socklen_t, .offset = offsetof(client_data_t, addr_len), .size = sizeof(socklen_t)},
		.player = {.name = "player", .type = TYPE_entity_t, .offset = offsetof(client_data_t, player), .size = sizeof(entity_t*)},
		.input_data_buffer = {.name = "input_data_buffer", .type = TYPE_input_data_t, .offset = offsetof(client_data_t, input_data_buffer), .size = sizeof(input_data_t)},
		.input_data_head = {.name = "input_data_head", .type = TYPE_u32, .offset = offsetof(client_data_t, input_data_head), .size = sizeof(u32)},
		.input_data_tail = {.name = "input_data_tail", .type = TYPE_u32, .offset = offsetof(client_data_t, input_data_tail), .size = sizeof(u32)},
	}
};

const static type_info_game_state_t type_info_game_state_t = {
	.name = "game_state_t",
	.type = TYPE_game_state_t,
	.member_count = 11,
	.members = {
		.window = {.name = "window", .type = TYPE_SDL_Window, .offset = offsetof(game_state_t, window), .size = sizeof(SDL_Window*)},
		.window_size = {.name = "window_size", .type = TYPE_vec2_t, .offset = offsetof(game_state_t, window_size), .size = sizeof(vec2_t)},
		.input_axis = {.name = "input_axis", .type = TYPE_vec2_t, .offset = offsetof(game_state_t, input_axis), .size = sizeof(vec2_t)},
		.entity_manager = {.name = "entity_manager", .type = TYPE_entity_manager_t, .offset = offsetof(game_state_t, entity_manager), .size = sizeof(entity_manager_t)},
		.player = {.name = "player", .type = TYPE_entity_t, .offset = offsetof(game_state_t, player), .size = sizeof(entity_t*)},
		.is_host = {.name = "is_host", .type = TYPE_bool8, .offset = offsetof(game_state_t, is_host), .size = sizeof(bool8)},
		.socket = {.name = "socket", .type = TYPE_s32, .offset = offsetof(game_state_t, socket), .size = sizeof(s32)},
		.host_address_data = {.name = "host_address_data", .type = TYPE_sockaddr_in_t, .offset = offsetof(game_state_t, host_address_data), .size = sizeof(sockaddr_in_t)},
		.client_id = {.name = "client_id", .type = TYPE_u32, .offset = offsetof(game_state_t, client_id), .size = sizeof(u32)},
		.clients = {.name = "clients", .type = TYPE_client_data_t, .offset = offsetof(game_state_t, clients), .size = sizeof(client_data_t)},
		.connected_client_count = {.name = "connected_client_count", .type = TYPE_u32, .offset = offsetof(game_state_t, connected_client_count), .size = sizeof(u32)},
	}
};

const static type_info_render_geometry_instance_t type_info_render_geometry_instance_t = {
	.name = "render_geometry_instance_t",
	.type = TYPE_render_geometry_instance_t,
	.member_count = 6,
	.members = {
		.transform = {.name = "transform", .type = TYPE_mat4_t, .offset = offsetof(render_geometry_instance_t, transform), .size = sizeof(mat4_t)},
		.color = {.name = "color", .type = TYPE_vec4_t, .offset = offsetof(render_geometry_instance_t, color), .size = sizeof(vec4_t)},
		.uv_min = {.name = "uv_min", .type = TYPE_vec2_t, .offset = offsetof(render_geometry_instance_t, uv_min), .size = sizeof(vec2_t)},
		.uv_max = {.name = "uv_max", .type = TYPE_vec2_t, .offset = offsetof(render_geometry_instance_t, uv_max), .size = sizeof(vec2_t)},
		.texture_index = {.name = "texture_index", .type = TYPE_u32, .offset = offsetof(render_geometry_instance_t, texture_index), .size = sizeof(u32)},
		.camera_index = {.name = "camera_index", .type = TYPE_u32, .offset = offsetof(render_geometry_instance_t, camera_index), .size = sizeof(u32)},
	}
};

const static type_info_render_geometry_batch_t type_info_render_geometry_batch_t = {
	.name = "render_geometry_batch_t",
	.type = TYPE_render_geometry_batch_t,
	.member_count = 6,
	.members = {
		.camera_data = {.name = "camera_data", .type = TYPE_render_camera_t, .offset = offsetof(render_geometry_batch_t, camera_data), .size = sizeof(render_camera_t)},
		.is_valid = {.name = "is_valid", .type = TYPE_bool32, .offset = offsetof(render_geometry_batch_t, is_valid), .size = sizeof(bool32)},
		.primitive_count = {.name = "primitive_count", .type = TYPE_u32, .offset = offsetof(render_geometry_batch_t, primitive_count), .size = sizeof(u32)},
		.master_array_start_offset = {.name = "master_array_start_offset", .type = TYPE_u32, .offset = offsetof(render_geometry_batch_t, master_array_start_offset), .size = sizeof(u32)},
		.instances = {.name = "instances", .type = TYPE_render_geometry_instance_t, .offset = offsetof(render_geometry_batch_t, instances), .size = sizeof(render_geometry_instance_t*)},
		.next_buffer = {.name = "next_buffer", .type = TYPE_render_geometry_batch_t, .offset = offsetof(render_geometry_batch_t, next_buffer), .size = sizeof(render_geometry_batch_t*)},
	}
};

const static type_info_render_group_t type_info_render_group_t = {
	.name = "render_group_t",
	.type = TYPE_render_group_t,
	.member_count = 9,
	.members = {
		.ID = {.name = "ID", .type = TYPE_u64, .offset = offsetof(render_group_t, ID), .size = sizeof(u64)},
		.dynamic_pipeline_state = {.name = "dynamic_pipeline_state", .type = TYPE_render_pipeline_state_t, .offset = offsetof(render_group_t, dynamic_pipeline_state), .size = sizeof(render_pipeline_state_t)},
		.shader = {.name = "shader", .type = TYPE_asset_handle_t, .offset = offsetof(render_group_t, shader), .size = sizeof(asset_handle_t*)},
		.textures = {.name = "textures", .type = TYPE_texture2D_t, .offset = offsetof(render_group_t, textures), .size = sizeof(texture2D_t*)},
		.current_texture_count = {.name = "current_texture_count", .type = TYPE_u32, .offset = offsetof(render_group_t, current_texture_count), .size = sizeof(u32)},
		.master_batch_array = {.name = "master_batch_array", .type = TYPE_render_geometry_instance_t, .offset = offsetof(render_group_t, master_batch_array), .size = sizeof(render_geometry_instance_t*)},
		.total_primitive_count = {.name = "total_primitive_count", .type = TYPE_u32, .offset = offsetof(render_group_t, total_primitive_count), .size = sizeof(u32)},
		.cached_buffer = {.name = "cached_buffer", .type = TYPE_render_geometry_batch_t, .offset = offsetof(render_group_t, cached_buffer), .size = sizeof(render_geometry_batch_t*)},
		.first_buffer = {.name = "first_buffer", .type = TYPE_render_geometry_batch_t, .offset = offsetof(render_group_t, first_buffer), .size = sizeof(render_geometry_batch_t)},
	}
};

const static type_info_draw_frame_t type_info_draw_frame_t = {
	.name = "draw_frame_t",
	.type = TYPE_draw_frame_t,
	.member_count = 10,
	.members = {
		.used_render_groups = {.name = "used_render_groups", .type = TYPE_render_group_t, .offset = offsetof(draw_frame_t, used_render_groups), .size = sizeof(render_group_t*)},
		.used_render_group_count = {.name = "used_render_group_count", .type = TYPE_u32, .offset = offsetof(draw_frame_t, used_render_group_count), .size = sizeof(u32)},
		.used_camera = {.name = "used_camera", .type = TYPE_render_camera_t, .offset = offsetof(draw_frame_t, used_camera), .size = sizeof(render_camera_t)},
		.used_camera_count = {.name = "used_camera_count", .type = TYPE_u32, .offset = offsetof(draw_frame_t, used_camera_count), .size = sizeof(u32)},
		.cached_camera_ID = {.name = "cached_camera_ID", .type = TYPE_u64_t, .offset = offsetof(draw_frame_t, cached_camera_ID), .size = sizeof(u64_t)},
		.active_render_layer = {.name = "active_render_layer", .type = TYPE_u32, .offset = offsetof(draw_frame_t, active_render_layer), .size = sizeof(u32)},
		.active_render_group = {.name = "active_render_group", .type = TYPE_render_group_t, .offset = offsetof(draw_frame_t, active_render_group), .size = sizeof(render_group_t*)},
		.active_camera = {.name = "active_camera", .type = TYPE_render_camera_t, .offset = offsetof(draw_frame_t, active_camera), .size = sizeof(render_camera_t*)},
		.active_shader = {.name = "active_shader", .type = TYPE_asset_handle_t, .offset = offsetof(draw_frame_t, active_shader), .size = sizeof(asset_handle_t*)},
		.active_pipeline_state = {.name = "active_pipeline_state", .type = TYPE_render_pipeline_state_t, .offset = offsetof(draw_frame_t, active_pipeline_state), .size = sizeof(render_pipeline_state_t)},
	}
};

const static type_info_render_state_t type_info_render_state_t = {
	.name = "render_state_t",
	.type = TYPE_render_state_t,
	.member_count = 6,
	.members = {
		.is_initialized = {.name = "is_initialized", .type = TYPE_bool8, .offset = offsetof(render_state_t, is_initialized), .size = sizeof(bool8)},
		.renderer_arena = {.name = "renderer_arena", .type = TYPE_memory_arena_t, .offset = offsetof(render_state_t, renderer_arena), .size = sizeof(memory_arena_t)},
		.render_context = {.name = "render_context", .type = TYPE_vulkan_render_context_t, .offset = offsetof(render_state_t, render_context), .size = sizeof(vulkan_render_context_t*)},
		.current_frame_data = {.name = "current_frame_data", .type = TYPE_vulkan_render_frame_state_t, .offset = offsetof(render_state_t, current_frame_data), .size = sizeof(vulkan_render_frame_state_t*)},
		.render_group_hash = {.name = "render_group_hash", .type = TYPE_render_group_t, .offset = offsetof(render_state_t, render_group_hash), .size = sizeof(render_group_t)},
		.draw_frame = {.name = "draw_frame", .type = TYPE_draw_frame_t, .offset = offsetof(render_state_t, draw_frame), .size = sizeof(draw_frame_t)},
	}
};

const static type_info_global_matrix_uniforms_t type_info_global_matrix_uniforms_t = {
	.name = "global_matrix_uniforms_t",
	.type = TYPE_global_matrix_uniforms_t,
	.member_count = 2,
	.members = {
		.view_matrix = {.name = "view_matrix", .type = TYPE_mat4_t, .offset = offsetof(global_matrix_uniforms_t, view_matrix), .size = sizeof(mat4_t)},
		.projection_matrix = {.name = "projection_matrix", .type = TYPE_mat4_t, .offset = offsetof(global_matrix_uniforms_t, projection_matrix), .size = sizeof(mat4_t)},
	}
};

const static type_info_push_constant_t type_info_push_constant_t = {
	.name = "push_constant_t",
	.type = TYPE_push_constant_t,
	.member_count = 1,
	.members = {
		.DrawColor = {.name = "DrawColor", .type = TYPE_vec4_t, .offset = offsetof(push_constant_t, DrawColor), .size = sizeof(vec4_t)},
	}
};

const static type_info_render_camera_t type_info_render_camera_t = {
	.name = "render_camera_t",
	.type = TYPE_render_camera_t,
	.member_count = 3,
	.members = {
		.view_matrix = {.name = "view_matrix", .type = TYPE_mat4_t, .offset = offsetof(render_camera_t, view_matrix), .size = sizeof(mat4_t)},
		.projection_matrix = {.name = "projection_matrix", .type = TYPE_mat4_t, .offset = offsetof(render_camera_t, projection_matrix), .size = sizeof(mat4_t)},
		.ID = {.name = "ID", .type = TYPE_u64, .offset = offsetof(render_camera_t, ID), .size = sizeof(u64)},
	}
};

const static type_info_vulkan_buffer_data_t type_info_vulkan_buffer_data_t = {
	.name = "vulkan_buffer_data_t",
	.type = TYPE_vulkan_buffer_data_t,
	.member_count = 8,
	.members = {
		.is_valid = {.name = "is_valid", .type = TYPE_bool8, .offset = offsetof(vulkan_buffer_data_t, is_valid), .size = sizeof(bool8)},
		.is_mapped = {.name = "is_mapped", .type = TYPE_bool8, .offset = offsetof(vulkan_buffer_data_t, is_mapped), .size = sizeof(bool8)},
		.buffer_size = {.name = "buffer_size", .type = TYPE_u64, .offset = offsetof(vulkan_buffer_data_t, buffer_size), .size = sizeof(u64)},
		.handle = {.name = "handle", .type = TYPE_VkBuffer, .offset = offsetof(vulkan_buffer_data_t, handle), .size = sizeof(VkBuffer)},
		.device_memory = {.name = "device_memory", .type = TYPE_VkDeviceMemory, .offset = offsetof(vulkan_buffer_data_t, device_memory), .size = sizeof(VkDeviceMemory)},
		.usage_flags = {.name = "usage_flags", .type = TYPE_VkBufferUsageFlagBits, .offset = offsetof(vulkan_buffer_data_t, usage_flags), .size = sizeof(VkBufferUsageFlagBits)},
		.memory_index = {.name = "memory_index", .type = TYPE_s32, .offset = offsetof(vulkan_buffer_data_t, memory_index), .size = sizeof(s32)},
		.memory_property_flags = {.name = "memory_property_flags", .type = TYPE_u32, .offset = offsetof(vulkan_buffer_data_t, memory_property_flags), .size = sizeof(u32)},
	}
};

const static type_info_vulkan_pipeline_data_t type_info_vulkan_pipeline_data_t = {
	.name = "vulkan_pipeline_data_t",
	.type = TYPE_vulkan_pipeline_data_t,
	.member_count = 3,
	.members = {
		.handle = {.name = "handle", .type = TYPE_VkPipeline, .offset = offsetof(vulkan_pipeline_data_t, handle), .size = sizeof(VkPipeline)},
		.binding = {.name = "binding", .type = TYPE_VkPipelineBindPoint, .offset = offsetof(vulkan_pipeline_data_t, binding), .size = sizeof(VkPipelineBindPoint)},
		.layout = {.name = "layout", .type = TYPE_VkPipelineLayout, .offset = offsetof(vulkan_pipeline_data_t, layout), .size = sizeof(VkPipelineLayout)},
	}
};

const static type_info_render_pipeline_state_t type_info_render_pipeline_state_t = {
	.name = "render_pipeline_state_t",
	.type = TYPE_render_pipeline_state_t,
	.member_count = 13,
	.members = {
		.blend_enabled = {.name = "blend_enabled", .type = TYPE_bool32, .offset = offsetof(render_pipeline_state_t, blend_enabled), .size = sizeof(bool32)},
		.src_color_blend_mode = {.name = "src_color_blend_mode", .type = TYPE_u32, .offset = offsetof(render_pipeline_state_t, src_color_blend_mode), .size = sizeof(u32)},
		.dst_color_blend_mode = {.name = "dst_color_blend_mode", .type = TYPE_u32, .offset = offsetof(render_pipeline_state_t, dst_color_blend_mode), .size = sizeof(u32)},
		.src_alpha_blend_mode = {.name = "src_alpha_blend_mode", .type = TYPE_u32, .offset = offsetof(render_pipeline_state_t, src_alpha_blend_mode), .size = sizeof(u32)},
		.dst_alpha_blend_mode = {.name = "dst_alpha_blend_mode", .type = TYPE_u32, .offset = offsetof(render_pipeline_state_t, dst_alpha_blend_mode), .size = sizeof(u32)},
		.color_blend_op = {.name = "color_blend_op", .type = TYPE_u32, .offset = offsetof(render_pipeline_state_t, color_blend_op), .size = sizeof(u32)},
		.alpha_blend_op = {.name = "alpha_blend_op", .type = TYPE_u32, .offset = offsetof(render_pipeline_state_t, alpha_blend_op), .size = sizeof(u32)},
		.depth_testing_enabled = {.name = "depth_testing_enabled", .type = TYPE_bool32, .offset = offsetof(render_pipeline_state_t, depth_testing_enabled), .size = sizeof(bool32)},
		.depth_writing_enabled = {.name = "depth_writing_enabled", .type = TYPE_u32, .offset = offsetof(render_pipeline_state_t, depth_writing_enabled), .size = sizeof(u32)},
		.depth_func = {.name = "depth_func", .type = TYPE_u32, .offset = offsetof(render_pipeline_state_t, depth_func), .size = sizeof(u32)},
		.stencil_enabled = {.name = "stencil_enabled", .type = TYPE_bool32, .offset = offsetof(render_pipeline_state_t, stencil_enabled), .size = sizeof(bool32)},
		.stencil_state = {.name = "stencil_state", .type = TYPE_u32, .offset = offsetof(render_pipeline_state_t, stencil_state), .size = sizeof(u32)},
		.stencil_keep = {.name = "stencil_keep", .type = TYPE_u32, .offset = offsetof(render_pipeline_state_t, stencil_keep), .size = sizeof(u32)},
	}
};

const static type_info_spv_vulkan_type_map_t type_info_spv_vulkan_type_map_t = {
	.name = "spv_vulkan_type_map_t",
	.type = TYPE_spv_vulkan_type_map_t,
	.member_count = 2,
	.members = {
		.spv_type = {.name = "spv_type", .type = TYPE_SpvReflectDescriptorType, .offset = offsetof(spv_vulkan_type_map_t, spv_type), .size = sizeof(SpvReflectDescriptorType)},
		.vk_type = {.name = "vk_type", .type = TYPE_VkDescriptorType, .offset = offsetof(spv_vulkan_type_map_t, vk_type), .size = sizeof(VkDescriptorType)},
	}
};

const static type_info_vulkan_shader_descriptor_set_info_t type_info_vulkan_shader_descriptor_set_info_t = {
	.name = "vulkan_shader_descriptor_set_info_t",
	.type = TYPE_vulkan_shader_descriptor_set_info_t,
	.member_count = 12,
	.members = {
		.is_valid = {.name = "is_valid", .type = TYPE_bool8, .offset = offsetof(vulkan_shader_descriptor_set_info_t, is_valid), .size = sizeof(bool8)},
		.set_type = {.name = "set_type", .type = TYPE_u32, .offset = offsetof(vulkan_shader_descriptor_set_info_t, set_type), .size = sizeof(u32)},
		.bindings = {.name = "bindings", .type = TYPE_VkDescriptorSetLayoutBinding, .offset = offsetof(vulkan_shader_descriptor_set_info_t, bindings), .size = sizeof(VkDescriptorSetLayoutBinding*)},
		.binding_count = {.name = "binding_count", .type = TYPE_u32, .offset = offsetof(vulkan_shader_descriptor_set_info_t, binding_count), .size = sizeof(u32)},
		.binding_upload_size = {.name = "binding_upload_size", .type = TYPE_u32, .offset = offsetof(vulkan_shader_descriptor_set_info_t, binding_upload_size), .size = sizeof(u32)},
		.image_views = {.name = "image_views", .type = TYPE_VkImageView, .offset = offsetof(vulkan_shader_descriptor_set_info_t, image_views), .size = sizeof(VkImageView)},
		.samplers = {.name = "samplers", .type = TYPE_VkSampler, .offset = offsetof(vulkan_shader_descriptor_set_info_t, samplers), .size = sizeof(VkSampler)},
		.image_count = {.name = "image_count", .type = TYPE_u32, .offset = offsetof(vulkan_shader_descriptor_set_info_t, image_count), .size = sizeof(u32)},
		.sampler_count = {.name = "sampler_count", .type = TYPE_u32, .offset = offsetof(vulkan_shader_descriptor_set_info_t, sampler_count), .size = sizeof(u32)},
		.sets = {.name = "sets", .type = TYPE_VkDescriptorSet, .offset = offsetof(vulkan_shader_descriptor_set_info_t, sets), .size = sizeof(VkDescriptorSet)},
		.uniform_buffer = {.name = "uniform_buffer", .type = TYPE_vulkan_buffer_data_t, .offset = offsetof(vulkan_shader_descriptor_set_info_t, uniform_buffer), .size = sizeof(vulkan_buffer_data_t)},
		.single_frame_uniform_buffer_size = {.name = "single_frame_uniform_buffer_size", .type = TYPE_u32, .offset = offsetof(vulkan_shader_descriptor_set_info_t, single_frame_uniform_buffer_size), .size = sizeof(u32)},
	}
};

const static type_info_vulkan_shader_uniform_texture_data_t type_info_vulkan_shader_uniform_texture_data_t = {
	.name = "vulkan_shader_uniform_texture_data_t",
	.type = TYPE_vulkan_shader_uniform_texture_data_t,
	.member_count = 3,
	.members = {
		.image_views = {.name = "image_views", .type = TYPE_VkImageView, .offset = offsetof(vulkan_shader_uniform_texture_data_t, image_views), .size = sizeof(VkImageView)},
		.image_samplers = {.name = "image_samplers", .type = TYPE_VkSampler, .offset = offsetof(vulkan_shader_uniform_texture_data_t, image_samplers), .size = sizeof(VkSampler)},
		.image_counter = {.name = "image_counter", .type = TYPE_u32, .offset = offsetof(vulkan_shader_uniform_texture_data_t, image_counter), .size = sizeof(u32)},
	}
};

const static type_info_vulkan_shader_uniform_data_range_t type_info_vulkan_shader_uniform_data_range_t = {
	.name = "vulkan_shader_uniform_data_range_t",
	.type = TYPE_vulkan_shader_uniform_data_range_t,
	.member_count = 2,
	.members = {
		.data = {.name = "data", .type = TYPE_void, .offset = offsetof(vulkan_shader_uniform_data_range_t, data), .size = sizeof(void*)},
		.data_size = {.name = "data_size", .type = TYPE_u64, .offset = offsetof(vulkan_shader_uniform_data_range_t, data_size), .size = sizeof(u64)},
	}
};

const static type_info_vulkan_shader_uniform_data_t type_info_vulkan_shader_uniform_data_t = {
	.name = "vulkan_shader_uniform_data_t",
	.type = TYPE_vulkan_shader_uniform_data_t,
	.member_count = 11,
	.members = {
		.owner_shader_id = {.name = "owner_shader_id", .type = TYPE_u32, .offset = offsetof(vulkan_shader_uniform_data_t, owner_shader_id), .size = sizeof(u32)},
		.uniform_type = {.name = "uniform_type", .type = TYPE_VkDescriptorType, .offset = offsetof(vulkan_shader_uniform_data_t, uniform_type), .size = sizeof(VkDescriptorType)},
		.set_type = {.name = "set_type", .type = TYPE_vulkan_shader_descriptor_set_binding_type_t, .offset = offsetof(vulkan_shader_uniform_data_t, set_type), .size = sizeof(vulkan_shader_descriptor_set_binding_type_t)},
		.uniform_location = {.name = "uniform_location", .type = TYPE_u32, .offset = offsetof(vulkan_shader_uniform_data_t, uniform_location), .size = sizeof(u32)},
		.push_constant_index = {.name = "push_constant_index", .type = TYPE_u32, .offset = offsetof(vulkan_shader_uniform_data_t, push_constant_index), .size = sizeof(u32)},
		.name = {.name = "name", .type = TYPE_string_t, .offset = offsetof(vulkan_shader_uniform_data_t, name), .size = sizeof(string_t)},
		.uniform_size = {.name = "uniform_size", .type = TYPE_u32, .offset = offsetof(vulkan_shader_uniform_data_t, uniform_size), .size = sizeof(u32)},
		.is_texture = {.name = "is_texture", .type = TYPE_bool8, .offset = offsetof(vulkan_shader_uniform_data_t, is_texture), .size = sizeof(bool8)},
		.mapped_buffer_update_size = {.name = "mapped_buffer_update_size", .type = TYPE_u32_t, .offset = offsetof(vulkan_shader_uniform_data_t, mapped_buffer_update_size), .size = sizeof(u32_t)},
		.mapped_uniform_buffer = {.name = "mapped_uniform_buffer", .type = TYPE_void, .offset = offsetof(vulkan_shader_uniform_data_t, mapped_uniform_buffer), .size = sizeof(void*)},
		.storage_buffer = {.name = "storage_buffer", .type = TYPE_vulkan_buffer_data_t, .offset = offsetof(vulkan_shader_uniform_data_t, storage_buffer), .size = sizeof(vulkan_buffer_data_t)},
	}
};

const static type_info_vulkan_shader_stage_info_t type_info_vulkan_shader_stage_info_t = {
	.name = "vulkan_shader_stage_info_t",
	.type = TYPE_vulkan_shader_stage_info_t,
	.member_count = 5,
	.members = {
		.type = {.name = "type", .type = TYPE_VkShaderStageFlagBits, .offset = offsetof(vulkan_shader_stage_info_t, type), .size = sizeof(VkShaderStageFlagBits)},
		.entry_point = {.name = "entry_point", .type = TYPE_char, .offset = offsetof(vulkan_shader_stage_info_t, entry_point), .size = sizeof(char*)},
		.module_create_info = {.name = "module_create_info", .type = TYPE_VkShaderModuleCreateInfo, .offset = offsetof(vulkan_shader_stage_info_t, module_create_info), .size = sizeof(VkShaderModuleCreateInfo)},
		.shader_stage_create_info = {.name = "shader_stage_create_info", .type = TYPE_VkPipelineShaderStageCreateInfo, .offset = offsetof(vulkan_shader_stage_info_t, shader_stage_create_info), .size = sizeof(VkPipelineShaderStageCreateInfo)},
		.handle = {.name = "handle", .type = TYPE_VkShaderModule, .offset = offsetof(vulkan_shader_stage_info_t, handle), .size = sizeof(VkShaderModule)},
	}
};

const static type_info_vulkan_shader_data_t type_info_vulkan_shader_data_t = {
	.name = "vulkan_shader_data_t",
	.type = TYPE_vulkan_shader_data_t,
	.member_count = 24,
	.members = {
		.shader_id = {.name = "shader_id", .type = TYPE_u32, .offset = offsetof(vulkan_shader_data_t, shader_id), .size = sizeof(u32)},
		.name = {.name = "name", .type = TYPE_string_t, .offset = offsetof(vulkan_shader_data_t, name), .size = sizeof(string_t)},
		.arena = {.name = "arena", .type = TYPE_memory_arena_t, .offset = offsetof(vulkan_shader_data_t, arena), .size = sizeof(memory_arena_t)},
		.spv_reflect_module = {.name = "spv_reflect_module", .type = TYPE_SpvReflectShaderModule, .offset = offsetof(vulkan_shader_data_t, spv_reflect_module), .size = sizeof(SpvReflectShaderModule)},
		.stages = {.name = "stages", .type = TYPE_vulkan_shader_stage_info_t, .offset = offsetof(vulkan_shader_data_t, stages), .size = sizeof(vulkan_shader_stage_info_t)},
		.stage_count = {.name = "stage_count", .type = TYPE_u32, .offset = offsetof(vulkan_shader_data_t, stage_count), .size = sizeof(u32)},
		.primary_pool = {.name = "primary_pool", .type = TYPE_VkDescriptorPool, .offset = offsetof(vulkan_shader_data_t, primary_pool), .size = sizeof(VkDescriptorPool)},
		.type_counts = {.name = "type_counts", .type = TYPE_u32, .offset = offsetof(vulkan_shader_data_t, type_counts), .size = sizeof(u32)},
		.layouts = {.name = "layouts", .type = TYPE_VkDescriptorSetLayout, .offset = offsetof(vulkan_shader_data_t, layouts), .size = sizeof(VkDescriptorSetLayout*)},
		.total_descriptor_set_count = {.name = "total_descriptor_set_count", .type = TYPE_u32, .offset = offsetof(vulkan_shader_data_t, total_descriptor_set_count), .size = sizeof(u32)},
		.used_descriptor_set_count = {.name = "used_descriptor_set_count", .type = TYPE_u32, .offset = offsetof(vulkan_shader_data_t, used_descriptor_set_count), .size = sizeof(u32)},
		.set_info = {.name = "set_info", .type = TYPE_vulkan_shader_descriptor_set_info_t, .offset = offsetof(vulkan_shader_data_t, set_info), .size = sizeof(vulkan_shader_descriptor_set_info_t*)},
		.push_constant_count = {.name = "push_constant_count", .type = TYPE_u32, .offset = offsetof(vulkan_shader_data_t, push_constant_count), .size = sizeof(u32)},
		.push_constant_data = {.name = "push_constant_data", .type = TYPE_VkPushConstantRange, .offset = offsetof(vulkan_shader_data_t, push_constant_data), .size = sizeof(VkPushConstantRange*)},
		.uniforms = {.name = "uniforms", .type = TYPE_vulkan_shader_uniform_data_t, .offset = offsetof(vulkan_shader_data_t, uniforms), .size = sizeof(vulkan_shader_uniform_data_t*)},
		.uniform_count = {.name = "uniform_count", .type = TYPE_u32, .offset = offsetof(vulkan_shader_data_t, uniform_count), .size = sizeof(u32)},
		.static_uniforms = {.name = "static_uniforms", .type = TYPE_vulkan_shader_uniform_data_t, .offset = offsetof(vulkan_shader_data_t, static_uniforms), .size = sizeof(vulkan_shader_uniform_data_t*)},
		.static_uniform_count = {.name = "static_uniform_count", .type = TYPE_u32, .offset = offsetof(vulkan_shader_data_t, static_uniform_count), .size = sizeof(u32)},
		.draw_uniforms = {.name = "draw_uniforms", .type = TYPE_vulkan_shader_uniform_data_t, .offset = offsetof(vulkan_shader_data_t, draw_uniforms), .size = sizeof(vulkan_shader_uniform_data_t*)},
		.draw_uniform_count = {.name = "draw_uniform_count", .type = TYPE_u32, .offset = offsetof(vulkan_shader_data_t, draw_uniform_count), .size = sizeof(u32)},
		.instance_uniforms = {.name = "instance_uniforms", .type = TYPE_vulkan_shader_uniform_data_t, .offset = offsetof(vulkan_shader_data_t, instance_uniforms), .size = sizeof(vulkan_shader_uniform_data_t*)},
		.instance_uniform_count = {.name = "instance_uniform_count", .type = TYPE_u32, .offset = offsetof(vulkan_shader_data_t, instance_uniform_count), .size = sizeof(u32)},
		.pipeline = {.name = "pipeline", .type = TYPE_vulkan_pipeline_data_t, .offset = offsetof(vulkan_shader_data_t, pipeline), .size = sizeof(vulkan_pipeline_data_t)},
		.camera_matrices = {.name = "camera_matrices", .type = TYPE_global_matrix_uniforms_t, .offset = offsetof(vulkan_shader_data_t, camera_matrices), .size = sizeof(global_matrix_uniforms_t)},
	}
};

const static type_info_vulkan_physical_device_swapchain_support_info_t type_info_vulkan_physical_device_swapchain_support_info_t = {
	.name = "vulkan_physical_device_swapchain_support_info_t",
	.type = TYPE_vulkan_physical_device_swapchain_support_info_t,
	.member_count = 5,
	.members = {
		.surface_capabilities = {.name = "surface_capabilities", .type = TYPE_VkSurfaceCapabilitiesKHR, .offset = offsetof(vulkan_physical_device_swapchain_support_info_t, surface_capabilities), .size = sizeof(VkSurfaceCapabilitiesKHR)},
		.valid_surface_formats = {.name = "valid_surface_formats", .type = TYPE_VkSurfaceFormatKHR, .offset = offsetof(vulkan_physical_device_swapchain_support_info_t, valid_surface_formats), .size = sizeof(VkSurfaceFormatKHR)},
		.valid_present_modes = {.name = "valid_present_modes", .type = TYPE_VkPresentModeKHR, .offset = offsetof(vulkan_physical_device_swapchain_support_info_t, valid_present_modes), .size = sizeof(VkPresentModeKHR)},
		.valid_surface_format_count = {.name = "valid_surface_format_count", .type = TYPE_u32, .offset = offsetof(vulkan_physical_device_swapchain_support_info_t, valid_surface_format_count), .size = sizeof(u32)},
		.valid_present_mode_count = {.name = "valid_present_mode_count", .type = TYPE_u32, .offset = offsetof(vulkan_physical_device_swapchain_support_info_t, valid_present_mode_count), .size = sizeof(u32)},
	}
};

const static type_info_vulkan_physical_device_queue_info_t type_info_vulkan_physical_device_queue_info_t = {
	.name = "vulkan_physical_device_queue_info_t",
	.type = TYPE_vulkan_physical_device_queue_info_t,
	.member_count = 4,
	.members = {
		.graphics_queue_family_index = {.name = "graphics_queue_family_index", .type = TYPE_u32, .offset = offsetof(vulkan_physical_device_queue_info_t, graphics_queue_family_index), .size = sizeof(u32)},
		.present_queue_family_index = {.name = "present_queue_family_index", .type = TYPE_u32, .offset = offsetof(vulkan_physical_device_queue_info_t, present_queue_family_index), .size = sizeof(u32)},
		.compute_queue_family_index = {.name = "compute_queue_family_index", .type = TYPE_u32, .offset = offsetof(vulkan_physical_device_queue_info_t, compute_queue_family_index), .size = sizeof(u32)},
		.transfer_queue_family_index = {.name = "transfer_queue_family_index", .type = TYPE_u32, .offset = offsetof(vulkan_physical_device_queue_info_t, transfer_queue_family_index), .size = sizeof(u32)},
	}
};

const static type_info_vulkan_physical_device_requirements_t type_info_vulkan_physical_device_requirements_t = {
	.name = "vulkan_physical_device_requirements_t",
	.type = TYPE_vulkan_physical_device_requirements_t,
	.member_count = 5,
	.members = {
		.has_graphics_queue = {.name = "has_graphics_queue", .type = TYPE_bool8, .offset = offsetof(vulkan_physical_device_requirements_t, has_graphics_queue), .size = sizeof(bool8)},
		.has_present_queue = {.name = "has_present_queue", .type = TYPE_bool8, .offset = offsetof(vulkan_physical_device_requirements_t, has_present_queue), .size = sizeof(bool8)},
		.has_transfer_queue = {.name = "has_transfer_queue", .type = TYPE_bool8, .offset = offsetof(vulkan_physical_device_requirements_t, has_transfer_queue), .size = sizeof(bool8)},
		.has_compute_queue = {.name = "has_compute_queue", .type = TYPE_bool8, .offset = offsetof(vulkan_physical_device_requirements_t, has_compute_queue), .size = sizeof(bool8)},
		.required_extensions = {.name = "required_extensions", .type = TYPE_char, .offset = offsetof(vulkan_physical_device_requirements_t, required_extensions), .size = sizeof(char*)},
	}
};

const static type_info_vulkan_physical_device_t type_info_vulkan_physical_device_t = {
	.name = "vulkan_physical_device_t",
	.type = TYPE_vulkan_physical_device_t,
	.member_count = 6,
	.members = {
		.handle = {.name = "handle", .type = TYPE_VkPhysicalDevice, .offset = offsetof(vulkan_physical_device_t, handle), .size = sizeof(VkPhysicalDevice)},
		.device_depth_format = {.name = "device_depth_format", .type = TYPE_VkFormat, .offset = offsetof(vulkan_physical_device_t, device_depth_format), .size = sizeof(VkFormat)},
		.properties = {.name = "properties", .type = TYPE_VkPhysicalDeviceProperties, .offset = offsetof(vulkan_physical_device_t, properties), .size = sizeof(VkPhysicalDeviceProperties)},
		.features = {.name = "features", .type = TYPE_VkPhysicalDeviceFeatures, .offset = offsetof(vulkan_physical_device_t, features), .size = sizeof(VkPhysicalDeviceFeatures)},
		.memory_properties = {.name = "memory_properties", .type = TYPE_VkPhysicalDeviceMemoryProperties, .offset = offsetof(vulkan_physical_device_t, memory_properties), .size = sizeof(VkPhysicalDeviceMemoryProperties)},
		.swapchain_support_info = {.name = "swapchain_support_info", .type = TYPE_vulkan_physical_device_swapchain_support_info_t, .offset = offsetof(vulkan_physical_device_t, swapchain_support_info), .size = sizeof(vulkan_physical_device_swapchain_support_info_t)},
	}
};

const static type_info_vulkan_rendering_device_t type_info_vulkan_rendering_device_t = {
	.name = "vulkan_rendering_device_t",
	.type = TYPE_vulkan_rendering_device_t,
	.member_count = 11,
	.members = {
		.physical_device = {.name = "physical_device", .type = TYPE_vulkan_physical_device_t, .offset = offsetof(vulkan_rendering_device_t, physical_device), .size = sizeof(vulkan_physical_device_t)},
		.graphics_queue_family_index = {.name = "graphics_queue_family_index", .type = TYPE_u32, .offset = offsetof(vulkan_rendering_device_t, graphics_queue_family_index), .size = sizeof(u32)},
		.present_queue_family_index = {.name = "present_queue_family_index", .type = TYPE_u32, .offset = offsetof(vulkan_rendering_device_t, present_queue_family_index), .size = sizeof(u32)},
		.compute_queue_family_index = {.name = "compute_queue_family_index", .type = TYPE_u32, .offset = offsetof(vulkan_rendering_device_t, compute_queue_family_index), .size = sizeof(u32)},
		.transfer_queue_family_index = {.name = "transfer_queue_family_index", .type = TYPE_u32, .offset = offsetof(vulkan_rendering_device_t, transfer_queue_family_index), .size = sizeof(u32)},
		.graphics_queue = {.name = "graphics_queue", .type = TYPE_VkQueue, .offset = offsetof(vulkan_rendering_device_t, graphics_queue), .size = sizeof(VkQueue)},
		.present_queue = {.name = "present_queue", .type = TYPE_VkQueue, .offset = offsetof(vulkan_rendering_device_t, present_queue), .size = sizeof(VkQueue)},
		.transfer_queue = {.name = "transfer_queue", .type = TYPE_VkQueue, .offset = offsetof(vulkan_rendering_device_t, transfer_queue), .size = sizeof(VkQueue)},
		.compute_queue = {.name = "compute_queue", .type = TYPE_VkQueue, .offset = offsetof(vulkan_rendering_device_t, compute_queue), .size = sizeof(VkQueue)},
		.graphics_command_pool = {.name = "graphics_command_pool", .type = TYPE_VkCommandPool, .offset = offsetof(vulkan_rendering_device_t, graphics_command_pool), .size = sizeof(VkCommandPool)},
		.logical_device = {.name = "logical_device", .type = TYPE_VkDevice, .offset = offsetof(vulkan_rendering_device_t, logical_device), .size = sizeof(VkDevice)},
	}
};

const static type_info_vulkan_fence_t type_info_vulkan_fence_t = {
	.name = "vulkan_fence_t",
	.type = TYPE_vulkan_fence_t,
	.member_count = 2,
	.members = {
		.handle = {.name = "handle", .type = TYPE_VkFence, .offset = offsetof(vulkan_fence_t, handle), .size = sizeof(VkFence)},
		.signaled = {.name = "signaled", .type = TYPE_bool8, .offset = offsetof(vulkan_fence_t, signaled), .size = sizeof(bool8)},
	}
};

const static type_info_vulkan_renderpass_data_t type_info_vulkan_renderpass_data_t = {
	.name = "vulkan_renderpass_data_t",
	.type = TYPE_vulkan_renderpass_data_t,
	.member_count = 7,
	.members = {
		.handle = {.name = "handle", .type = TYPE_VkRenderPass, .offset = offsetof(vulkan_renderpass_data_t, handle), .size = sizeof(VkRenderPass)},
		.offset = {.name = "offset", .type = TYPE_vec2_t, .offset = offsetof(vulkan_renderpass_data_t, offset), .size = sizeof(vec2_t)},
		.size = {.name = "size", .type = TYPE_vec2_t, .offset = offsetof(vulkan_renderpass_data_t, size), .size = sizeof(vec2_t)},
		.clear_color = {.name = "clear_color", .type = TYPE_vec4_t, .offset = offsetof(vulkan_renderpass_data_t, clear_color), .size = sizeof(vec4_t)},
		.depth_clear = {.name = "depth_clear", .type = TYPE_float32, .offset = offsetof(vulkan_renderpass_data_t, depth_clear), .size = sizeof(float32)},
		.stencil_clear = {.name = "stencil_clear", .type = TYPE_u32, .offset = offsetof(vulkan_renderpass_data_t, stencil_clear), .size = sizeof(u32)},
		.renderpass_state = {.name = "renderpass_state", .type = TYPE_vulkan_renderpass_state_t, .offset = offsetof(vulkan_renderpass_data_t, renderpass_state), .size = sizeof(vulkan_renderpass_state_t)},
	}
};

const static type_info_vulkan_framebuffer_data_t type_info_vulkan_framebuffer_data_t = {
	.name = "vulkan_framebuffer_data_t",
	.type = TYPE_vulkan_framebuffer_data_t,
	.member_count = 4,
	.members = {
		.handle = {.name = "handle", .type = TYPE_VkFramebuffer, .offset = offsetof(vulkan_framebuffer_data_t, handle), .size = sizeof(VkFramebuffer)},
		.renderpass = {.name = "renderpass", .type = TYPE_vulkan_renderpass_data_t, .offset = offsetof(vulkan_framebuffer_data_t, renderpass), .size = sizeof(vulkan_renderpass_data_t*)},
		.attachments = {.name = "attachments", .type = TYPE_VkImageView, .offset = offsetof(vulkan_framebuffer_data_t, attachments), .size = sizeof(VkImageView*)},
		.attachment_count = {.name = "attachment_count", .type = TYPE_u32, .offset = offsetof(vulkan_framebuffer_data_t, attachment_count), .size = sizeof(u32)},
	}
};

const static type_info_vulkan_image_data_t type_info_vulkan_image_data_t = {
	.name = "vulkan_image_data_t",
	.type = TYPE_vulkan_image_data_t,
	.member_count = 7,
	.members = {
		.handle = {.name = "handle", .type = TYPE_VkImage, .offset = offsetof(vulkan_image_data_t, handle), .size = sizeof(VkImage)},
		.memory = {.name = "memory", .type = TYPE_VkDeviceMemory, .offset = offsetof(vulkan_image_data_t, memory), .size = sizeof(VkDeviceMemory)},
		.format = {.name = "format", .type = TYPE_VkFormat, .offset = offsetof(vulkan_image_data_t, format), .size = sizeof(VkFormat)},
		.layout = {.name = "layout", .type = TYPE_VkImageLayout, .offset = offsetof(vulkan_image_data_t, layout), .size = sizeof(VkImageLayout)},
		.view = {.name = "view", .type = TYPE_VkImageView, .offset = offsetof(vulkan_image_data_t, view), .size = sizeof(VkImageView)},
		.width = {.name = "width", .type = TYPE_u32, .offset = offsetof(vulkan_image_data_t, width), .size = sizeof(u32)},
		.height = {.name = "height", .type = TYPE_u32, .offset = offsetof(vulkan_image_data_t, height), .size = sizeof(u32)},
	}
};

const static type_info_vulkan_texture_t type_info_vulkan_texture_t = {
	.name = "vulkan_texture_t",
	.type = TYPE_vulkan_texture_t,
	.member_count = 3,
	.members = {
		.current_generation = {.name = "current_generation", .type = TYPE_u32, .offset = offsetof(vulkan_texture_t, current_generation), .size = sizeof(u32)},
		.image_data = {.name = "image_data", .type = TYPE_vulkan_image_data_t, .offset = offsetof(vulkan_texture_t, image_data), .size = sizeof(vulkan_image_data_t)},
		.sampler = {.name = "sampler", .type = TYPE_VkSampler, .offset = offsetof(vulkan_texture_t, sampler), .size = sizeof(VkSampler)},
	}
};

const static type_info_vulkan_swapchain_data_t type_info_vulkan_swapchain_data_t = {
	.name = "vulkan_swapchain_data_t",
	.type = TYPE_vulkan_swapchain_data_t,
	.member_count = 12,
	.members = {
		.is_valid = {.name = "is_valid", .type = TYPE_bool8, .offset = offsetof(vulkan_swapchain_data_t, is_valid), .size = sizeof(bool8)},
		.arena = {.name = "arena", .type = TYPE_memory_arena_t, .offset = offsetof(vulkan_swapchain_data_t, arena), .size = sizeof(memory_arena_t)},
		.handle = {.name = "handle", .type = TYPE_VkSwapchainKHR, .offset = offsetof(vulkan_swapchain_data_t, handle), .size = sizeof(VkSwapchainKHR)},
		.image_format = {.name = "image_format", .type = TYPE_VkSurfaceFormatKHR, .offset = offsetof(vulkan_swapchain_data_t, image_format), .size = sizeof(VkSurfaceFormatKHR)},
		.present_mode = {.name = "present_mode", .type = TYPE_VkPresentModeKHR, .offset = offsetof(vulkan_swapchain_data_t, present_mode), .size = sizeof(VkPresentModeKHR)},
		.depth_attachment = {.name = "depth_attachment", .type = TYPE_vulkan_image_data_t, .offset = offsetof(vulkan_swapchain_data_t, depth_attachment), .size = sizeof(vulkan_image_data_t)},
		.has_depth_attachment = {.name = "has_depth_attachment", .type = TYPE_bool32, .offset = offsetof(vulkan_swapchain_data_t, has_depth_attachment), .size = sizeof(bool32)},
		.max_frames_in_flight = {.name = "max_frames_in_flight", .type = TYPE_u32, .offset = offsetof(vulkan_swapchain_data_t, max_frames_in_flight), .size = sizeof(u32)},
		.image_count = {.name = "image_count", .type = TYPE_u32, .offset = offsetof(vulkan_swapchain_data_t, image_count), .size = sizeof(u32)},
		.framebuffers = {.name = "framebuffers", .type = TYPE_vulkan_framebuffer_data_t, .offset = offsetof(vulkan_swapchain_data_t, framebuffers), .size = sizeof(vulkan_framebuffer_data_t*)},
		.images = {.name = "images", .type = TYPE_VkImage, .offset = offsetof(vulkan_swapchain_data_t, images), .size = sizeof(VkImage*)},
		.views = {.name = "views", .type = TYPE_VkImageView, .offset = offsetof(vulkan_swapchain_data_t, views), .size = sizeof(VkImageView*)},
	}
};

const static type_info_vulkan_command_buffer_data_t type_info_vulkan_command_buffer_data_t = {
	.name = "vulkan_command_buffer_data_t",
	.type = TYPE_vulkan_command_buffer_data_t,
	.member_count = 5,
	.members = {
		.handle = {.name = "handle", .type = TYPE_VkCommandBuffer, .offset = offsetof(vulkan_command_buffer_data_t, handle), .size = sizeof(VkCommandBuffer)},
		.owner_pool = {.name = "owner_pool", .type = TYPE_VkCommandPool, .offset = offsetof(vulkan_command_buffer_data_t, owner_pool), .size = sizeof(VkCommandPool)},
		.state = {.name = "state", .type = TYPE_vulkan_command_buffer_state_t, .offset = offsetof(vulkan_command_buffer_data_t, state), .size = sizeof(vulkan_command_buffer_state_t)},
		.is_primary_buffer = {.name = "is_primary_buffer", .type = TYPE_bool8, .offset = offsetof(vulkan_command_buffer_data_t, is_primary_buffer), .size = sizeof(bool8)},
		.is_single_use = {.name = "is_single_use", .type = TYPE_bool8, .offset = offsetof(vulkan_command_buffer_data_t, is_single_use), .size = sizeof(bool8)},
	}
};

const static type_info_vulkan_render_backend_function_data_t type_info_vulkan_render_backend_function_data_t = {
	.name = "vulkan_render_backend_function_data_t",
	.type = TYPE_vulkan_render_backend_function_data_t,
	.member_count = 6,
	.members = {
		.create_gpu_texture = {.name = "create_gpu_texture", .type = TYPE_void, .offset = offsetof(vulkan_render_backend_function_data_t, create_gpu_texture), .size = sizeof(void*)},
		.create_gpu_shader = {.name = "create_gpu_shader", .type = TYPE_void, .offset = offsetof(vulkan_render_backend_function_data_t, create_gpu_shader), .size = sizeof(void*)},
		.create_gpu_buffer = {.name = "create_gpu_buffer", .type = TYPE_void, .offset = offsetof(vulkan_render_backend_function_data_t, create_gpu_buffer), .size = sizeof(void*)},
		.destroy_gpu_texture = {.name = "destroy_gpu_texture", .type = TYPE_void, .offset = offsetof(vulkan_render_backend_function_data_t, destroy_gpu_texture), .size = sizeof(void*)},
		.destroy_gpu_shader = {.name = "destroy_gpu_shader", .type = TYPE_void, .offset = offsetof(vulkan_render_backend_function_data_t, destroy_gpu_shader), .size = sizeof(void*)},
		.destroy_gpu_buffer = {.name = "destroy_gpu_buffer", .type = TYPE_void, .offset = offsetof(vulkan_render_backend_function_data_t, destroy_gpu_buffer), .size = sizeof(void*)},
	}
};

const static type_info_vulkan_render_frame_state_t type_info_vulkan_render_frame_state_t = {
	.name = "vulkan_render_frame_state_t",
	.type = TYPE_vulkan_render_frame_state_t,
	.member_count = 8,
	.members = {
		.image_render_idle_fence = {.name = "image_render_idle_fence", .type = TYPE_vulkan_fence_t, .offset = offsetof(vulkan_render_frame_state_t, image_render_idle_fence), .size = sizeof(vulkan_fence_t*)},
		.frame_in_flight_fence_ptr = {.name = "frame_in_flight_fence_ptr", .type = TYPE_vulkan_fence_t, .offset = offsetof(vulkan_render_frame_state_t, frame_in_flight_fence_ptr), .size = sizeof(vulkan_fence_t*)},
		.image_avaliable_semaphore = {.name = "image_avaliable_semaphore", .type = TYPE_VkSemaphore, .offset = offsetof(vulkan_render_frame_state_t, image_avaliable_semaphore), .size = sizeof(VkSemaphore*)},
		.presentation_complete_semaphore = {.name = "presentation_complete_semaphore", .type = TYPE_VkSemaphore, .offset = offsetof(vulkan_render_frame_state_t, presentation_complete_semaphore), .size = sizeof(VkSemaphore*)},
		.current_framebuffer = {.name = "current_framebuffer", .type = TYPE_vulkan_framebuffer_data_t, .offset = offsetof(vulkan_render_frame_state_t, current_framebuffer), .size = sizeof(vulkan_framebuffer_data_t*)},
		.render_command_buffer = {.name = "render_command_buffer", .type = TYPE_vulkan_command_buffer_data_t, .offset = offsetof(vulkan_render_frame_state_t, render_command_buffer), .size = sizeof(vulkan_command_buffer_data_t*)},
		.instanced_rendering_buffer = {.name = "instanced_rendering_buffer", .type = TYPE_vulkan_buffer_data_t, .offset = offsetof(vulkan_render_frame_state_t, instanced_rendering_buffer), .size = sizeof(vulkan_buffer_data_t*)},
		.bound_shader = {.name = "bound_shader", .type = TYPE_vulkan_shader_data_t, .offset = offsetof(vulkan_render_frame_state_t, bound_shader), .size = sizeof(vulkan_shader_data_t*)},
	}
};

const static type_info_vulkan_render_context_t type_info_vulkan_render_context_t = {
	.name = "vulkan_render_context_t",
	.type = TYPE_vulkan_render_context_t,
	.member_count = 39,
	.members = {
		.initialization_arena = {.name = "initialization_arena", .type = TYPE_memory_arena_t, .offset = offsetof(vulkan_render_context_t, initialization_arena), .size = sizeof(memory_arena_t)},
		.frame_arena = {.name = "frame_arena", .type = TYPE_memory_arena_t, .offset = offsetof(vulkan_render_context_t, frame_arena), .size = sizeof(memory_arena_t)},
		.permanent_arena = {.name = "permanent_arena", .type = TYPE_memory_arena_t, .offset = offsetof(vulkan_render_context_t, permanent_arena), .size = sizeof(memory_arena_t)},
		.additional_buffer_count = {.name = "additional_buffer_count", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, additional_buffer_count), .size = sizeof(u32)},
		.window = {.name = "window", .type = TYPE_SDL_Window, .offset = offsetof(vulkan_render_context_t, window), .size = sizeof(SDL_Window*)},
		.window_width = {.name = "window_width", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, window_width), .size = sizeof(u32)},
		.window_height = {.name = "window_height", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, window_height), .size = sizeof(u32)},
		.instance = {.name = "instance", .type = TYPE_VkInstance, .offset = offsetof(vulkan_render_context_t, instance), .size = sizeof(VkInstance)},
		.allocators = {.name = "allocators", .type = TYPE_VkAllocationCallbacks, .offset = offsetof(vulkan_render_context_t, allocators), .size = sizeof(VkAllocationCallbacks*)},
		.render_surface = {.name = "render_surface", .type = TYPE_VkSurfaceKHR, .offset = offsetof(vulkan_render_context_t, render_surface), .size = sizeof(VkSurfaceKHR)},
		.rendering_device = {.name = "rendering_device", .type = TYPE_vulkan_rendering_device_t, .offset = offsetof(vulkan_render_context_t, rendering_device), .size = sizeof(vulkan_rendering_device_t)},
		.swapchain = {.name = "swapchain", .type = TYPE_vulkan_swapchain_data_t, .offset = offsetof(vulkan_render_context_t, swapchain), .size = sizeof(vulkan_swapchain_data_t)},
		.current_image_index = {.name = "current_image_index", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, current_image_index), .size = sizeof(u32)},
		.current_frame_index = {.name = "current_frame_index", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, current_frame_index), .size = sizeof(u32)},
		.framebuffer_width = {.name = "framebuffer_width", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, framebuffer_width), .size = sizeof(u32)},
		.framebuffer_height = {.name = "framebuffer_height", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, framebuffer_height), .size = sizeof(u32)},
		.cached_framebuffer_width = {.name = "cached_framebuffer_width", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, cached_framebuffer_width), .size = sizeof(u32)},
		.cached_framebuffer_height = {.name = "cached_framebuffer_height", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, cached_framebuffer_height), .size = sizeof(u32)},
		.current_framebuffer_size_generation = {.name = "current_framebuffer_size_generation", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, current_framebuffer_size_generation), .size = sizeof(u32)},
		.last_framebuffer_size_generation = {.name = "last_framebuffer_size_generation", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, last_framebuffer_size_generation), .size = sizeof(u32)},
		.recreating_swapchain = {.name = "recreating_swapchain", .type = TYPE_bool8, .offset = offsetof(vulkan_render_context_t, recreating_swapchain), .size = sizeof(bool8)},
		.image_render_idle_fences = {.name = "image_render_idle_fences", .type = TYPE_vulkan_fence_t, .offset = offsetof(vulkan_render_context_t, image_render_idle_fences), .size = sizeof(vulkan_fence_t*)},
		.frame_in_flight_fence_ptrs = {.name = "frame_in_flight_fence_ptrs", .type = TYPE_vulkan_fence_t, .offset = offsetof(vulkan_render_context_t, frame_in_flight_fence_ptrs), .size = sizeof(vulkan_fence_t*)},
		.image_avaliable_semaphores = {.name = "image_avaliable_semaphores", .type = TYPE_VkSemaphore, .offset = offsetof(vulkan_render_context_t, image_avaliable_semaphores), .size = sizeof(VkSemaphore*)},
		.presentation_complete_semaphores = {.name = "presentation_complete_semaphores", .type = TYPE_VkSemaphore, .offset = offsetof(vulkan_render_context_t, presentation_complete_semaphores), .size = sizeof(VkSemaphore*)},
		.render_command_buffers = {.name = "render_command_buffers", .type = TYPE_vulkan_command_buffer_data_t, .offset = offsetof(vulkan_render_context_t, render_command_buffers), .size = sizeof(vulkan_command_buffer_data_t*)},
		.frames = {.name = "frames", .type = TYPE_vulkan_render_frame_state_t, .offset = offsetof(vulkan_render_context_t, frames), .size = sizeof(vulkan_render_frame_state_t*)},
		.current_frame = {.name = "current_frame", .type = TYPE_vulkan_render_frame_state_t, .offset = offsetof(vulkan_render_context_t, current_frame), .size = sizeof(vulkan_render_frame_state_t*)},
		.instanced_rendering_buffer = {.name = "instanced_rendering_buffer", .type = TYPE_vulkan_buffer_data_t, .offset = offsetof(vulkan_render_context_t, instanced_rendering_buffer), .size = sizeof(vulkan_buffer_data_t)},
		.index_buffer = {.name = "index_buffer", .type = TYPE_vulkan_buffer_data_t, .offset = offsetof(vulkan_render_context_t, index_buffer), .size = sizeof(vulkan_buffer_data_t)},
		.vertex_buffer = {.name = "vertex_buffer", .type = TYPE_vulkan_buffer_data_t, .offset = offsetof(vulkan_render_context_t, vertex_buffer), .size = sizeof(vulkan_buffer_data_t)},
		.main_renderpass = {.name = "main_renderpass", .type = TYPE_vulkan_renderpass_data_t, .offset = offsetof(vulkan_render_context_t, main_renderpass), .size = sizeof(vulkan_renderpass_data_t)},
		.default_shader = {.name = "default_shader", .type = TYPE_asset_handle_t, .offset = offsetof(vulkan_render_context_t, default_shader), .size = sizeof(asset_handle_t*)},
		.default_texture = {.name = "default_texture", .type = TYPE_asset_handle_t, .offset = offsetof(vulkan_render_context_t, default_texture), .size = sizeof(asset_handle_t*)},
		.invalid_texture_data = {.name = "invalid_texture_data", .type = TYPE_texture2D_t, .offset = offsetof(vulkan_render_context_t, invalid_texture_data), .size = sizeof(texture2D_t*)},
		.vertex_offset = {.name = "vertex_offset", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, vertex_offset), .size = sizeof(u32)},
		.geometry_index = {.name = "geometry_index", .type = TYPE_u32, .offset = offsetof(vulkan_render_context_t, geometry_index), .size = sizeof(u32)},
		.test_camera = {.name = "test_camera", .type = TYPE_render_camera_t, .offset = offsetof(vulkan_render_context_t, test_camera), .size = sizeof(render_camera_t)},
		.debug_callback = {.name = "debug_callback", .type = TYPE_VkDebugUtilsMessengerEXT, .offset = offsetof(vulkan_render_context_t, debug_callback), .size = sizeof(VkDebugUtilsMessengerEXT)},
	}
};

const static type_info_asset_handle_t type_info_asset_handle_t = {
	.name = "asset_handle_t",
	.type = TYPE_asset_handle_t,
	.member_count = 5,
	.members = {
		.is_valid = {.name = "is_valid", .type = TYPE_bool32, .offset = offsetof(asset_handle_t, is_valid), .size = sizeof(bool32)},
		.type = {.name = "type", .type = TYPE_asset_type_t, .offset = offsetof(asset_handle_t, type), .size = sizeof(asset_type_t)},
		.owner_asset_file_index = {.name = "owner_asset_file_index", .type = TYPE_s32, .offset = offsetof(asset_handle_t, owner_asset_file_index), .size = sizeof(s32)},
		.subtexture_data = {.name = "subtexture_data", .type = TYPE_subtexture_data_t, .offset = offsetof(asset_handle_t, subtexture_data), .size = sizeof(subtexture_data_t*)},
		.slot = {.name = "slot", .type = TYPE_asset_slot_t, .offset = offsetof(asset_handle_t, slot), .size = sizeof(asset_slot_t*)},
	}
};

const static type_info_bitmap_t type_info_bitmap_t = {
	.name = "bitmap_t",
	.type = TYPE_bitmap_t,
	.member_count = 5,
	.members = {
		.width = {.name = "width", .type = TYPE_u32, .offset = offsetof(bitmap_t, width), .size = sizeof(u32)},
		.height = {.name = "height", .type = TYPE_u32, .offset = offsetof(bitmap_t, height), .size = sizeof(u32)},
		.channels = {.name = "channels", .type = TYPE_u32, .offset = offsetof(bitmap_t, channels), .size = sizeof(u32)},
		.format = {.name = "format", .type = TYPE_u32, .offset = offsetof(bitmap_t, format), .size = sizeof(u32)},
		.pixels = {.name = "pixels", .type = TYPE_string_t, .offset = offsetof(bitmap_t, pixels), .size = sizeof(string_t)},
	}
};

const static type_info_texture2D_t type_info_texture2D_t = {
	.name = "texture2D_t",
	.type = TYPE_texture2D_t,
	.member_count = 2,
	.members = {
		.bitmap = {.name = "bitmap", .type = TYPE_bitmap_t, .offset = offsetof(texture2D_t, bitmap), .size = sizeof(bitmap_t)},
		.gpu_data = {.name = "gpu_data", .type = TYPE_vulkan_texture_t, .offset = offsetof(texture2D_t, gpu_data), .size = sizeof(vulkan_texture_t)},
	}
};

const static type_info_subtexture_data_t type_info_subtexture_data_t = {
	.name = "subtexture_data_t",
	.type = TYPE_subtexture_data_t,
	.member_count = 6,
	.members = {
		.uv_min = {.name = "uv_min", .type = TYPE_vec2_t, .offset = offsetof(subtexture_data_t, uv_min), .size = sizeof(vec2_t)},
		.uv_max = {.name = "uv_max", .type = TYPE_vec2_t, .offset = offsetof(subtexture_data_t, uv_max), .size = sizeof(vec2_t)},
		.offset = {.name = "offset", .type = TYPE_vec2_t, .offset = offsetof(subtexture_data_t, offset), .size = sizeof(vec2_t)},
		.size = {.name = "size", .type = TYPE_vec2_t, .offset = offsetof(subtexture_data_t, size), .size = sizeof(vec2_t)},
		.atlas_subtexture_index = {.name = "atlas_subtexture_index", .type = TYPE_u32, .offset = offsetof(subtexture_data_t, atlas_subtexture_index), .size = sizeof(u32)},
		.atlas = {.name = "atlas", .type = TYPE_texture_atlas_t, .offset = offsetof(subtexture_data_t, atlas), .size = sizeof(texture_atlas_t*)},
	}
};

const static type_info_texture_atlas_t type_info_texture_atlas_t = {
	.name = "texture_atlas_t",
	.type = TYPE_texture_atlas_t,
	.member_count = 12,
	.members = {
		.texture = {.name = "texture", .type = TYPE_texture2D_t, .offset = offsetof(texture_atlas_t, texture), .size = sizeof(texture2D_t)},
		.bitmap_data = {.name = "bitmap_data", .type = TYPE_bitmap_t, .offset = offsetof(texture_atlas_t, bitmap_data), .size = sizeof(bitmap_t*)},
		.ID = {.name = "ID", .type = TYPE_u32, .offset = offsetof(texture_atlas_t, ID), .size = sizeof(u32)},
		.merge_counter = {.name = "merge_counter", .type = TYPE_u32, .offset = offsetof(texture_atlas_t, merge_counter), .size = sizeof(u32)},
		.textures_to_merge = {.name = "textures_to_merge", .type = TYPE_asset_handle_t, .offset = offsetof(texture_atlas_t, textures_to_merge), .size = sizeof(asset_handle_t*)},
		.packed_subtextures = {.name = "packed_subtextures", .type = TYPE_subtexture_data_t, .offset = offsetof(texture_atlas_t, packed_subtextures), .size = sizeof(subtexture_data_t)},
		.packed_subtexture_count = {.name = "packed_subtexture_count", .type = TYPE_u32, .offset = offsetof(texture_atlas_t, packed_subtexture_count), .size = sizeof(u32)},
		.is_valid = {.name = "is_valid", .type = TYPE_bool32, .offset = offsetof(texture_atlas_t, is_valid), .size = sizeof(bool32)},
		.atlas_cursor_x = {.name = "atlas_cursor_x", .type = TYPE_u32, .offset = offsetof(texture_atlas_t, atlas_cursor_x), .size = sizeof(u32)},
		.atlas_cursor_y = {.name = "atlas_cursor_y", .type = TYPE_u32, .offset = offsetof(texture_atlas_t, atlas_cursor_y), .size = sizeof(u32)},
		.tallest_y = {.name = "tallest_y", .type = TYPE_u32, .offset = offsetof(texture_atlas_t, tallest_y), .size = sizeof(u32)},
		.atlas_size = {.name = "atlas_size", .type = TYPE_u32, .offset = offsetof(texture_atlas_t, atlas_size), .size = sizeof(u32)},
	}
};

const static type_info_shader_t type_info_shader_t = {
	.name = "shader_t",
	.type = TYPE_shader_t,
	.member_count = 4,
	.members = {
		.ID = {.name = "ID", .type = TYPE_u32, .offset = offsetof(shader_t, ID), .size = sizeof(u32)},
		.shader_data = {.name = "shader_data", .type = TYPE_vulkan_shader_data_t, .offset = offsetof(shader_t, shader_data), .size = sizeof(vulkan_shader_data_t)},
		.camera_uniform = {.name = "camera_uniform", .type = TYPE_vulkan_shader_uniform_data_t, .offset = offsetof(shader_t, camera_uniform), .size = sizeof(vulkan_shader_uniform_data_t*)},
		.texture_uniform = {.name = "texture_uniform", .type = TYPE_vulkan_shader_uniform_data_t, .offset = offsetof(shader_t, texture_uniform), .size = sizeof(vulkan_shader_uniform_data_t*)},
	}
};

const static type_info_material_t type_info_material_t = {
	.name = "material_t",
	.type = TYPE_material_t,
	.member_count = 6,
	.members = {
		.ID = {.name = "ID", .type = TYPE_u64, .offset = offsetof(material_t, ID), .size = sizeof(u64)},
		.name = {.name = "name", .type = TYPE_string_t, .offset = offsetof(material_t, name), .size = sizeof(string_t)},
		.shader = {.name = "shader", .type = TYPE_shader_t, .offset = offsetof(material_t, shader), .size = sizeof(shader_t*)},
		.diffuse_map = {.name = "diffuse_map", .type = TYPE_texture2D_t, .offset = offsetof(material_t, diffuse_map), .size = sizeof(texture2D_t*)},
		.normal_map = {.name = "normal_map", .type = TYPE_texture2D_t, .offset = offsetof(material_t, normal_map), .size = sizeof(texture2D_t*)},
		.pipeline_state = {.name = "pipeline_state", .type = TYPE_render_pipeline_state_t, .offset = offsetof(material_t, pipeline_state), .size = sizeof(render_pipeline_state_t)},
	}
};

const static type_info_asset_slot_t type_info_asset_slot_t = {
	.name = "asset_slot_t",
	.type = TYPE_asset_slot_t,
	.member_count = 10,
	.members = {
		.slot_state = {.name = "slot_state", .type = TYPE_asset_slot_load_status_t, .offset = offsetof(asset_slot_t, slot_state), .size = sizeof(asset_slot_load_status_t)},
		.type = {.name = "type", .type = TYPE_asset_type_t, .offset = offsetof(asset_slot_t, type), .size = sizeof(asset_type_t)},
		.name = {.name = "name", .type = TYPE_string_t, .offset = offsetof(asset_slot_t, name), .size = sizeof(string_t)},
		.owner_asset_file = {.name = "owner_asset_file", .type = TYPE_file_t, .offset = offsetof(asset_slot_t, owner_asset_file), .size = sizeof(file_t)},
		.package_entry = {.name = "package_entry", .type = TYPE_jfd_package_entry_t, .offset = offsetof(asset_slot_t, package_entry), .size = sizeof(jfd_package_entry_t*)},
		.package_generation = {.name = "package_generation", .type = TYPE_u32, .offset = offsetof(asset_slot_t, package_generation), .size = sizeof(u32)},
		.ref_counter = {.name = "ref_counter", .type = TYPE_u32, .offset = offsetof(asset_slot_t, ref_counter), .size = sizeof(u32)},
		.texture = {.name = "texture", .type = TYPE_texture2D_t, .offset = offsetof(asset_slot_t, texture), .size = sizeof(texture2D_t)},
		.shader = {.name = "shader", .type = TYPE_shader_t, .offset = offsetof(asset_slot_t, shader), .size = sizeof(shader_t)},
		.material = {.name = "material", .type = TYPE_material_t, .offset = offsetof(asset_slot_t, material), .size = sizeof(material_t)},
	}
};

const static type_info_asset_manager_asset_file_data_t type_info_asset_manager_asset_file_data_t = {
	.name = "asset_manager_asset_file_data_t",
	.type = TYPE_asset_manager_asset_file_data_t,
	.member_count = 10,
	.members = {
		.is_initialized = {.name = "is_initialized", .type = TYPE_bool8, .offset = offsetof(asset_manager_asset_file_data_t, is_initialized), .size = sizeof(bool8)},
		.ID = {.name = "ID", .type = TYPE_u32, .offset = offsetof(asset_manager_asset_file_data_t, ID), .size = sizeof(u32)},
		.init_arena = {.name = "init_arena", .type = TYPE_memory_arena_t, .offset = offsetof(asset_manager_asset_file_data_t, init_arena), .size = sizeof(memory_arena_t)},
		.load_status = {.name = "load_status", .type = TYPE_asset_slot_load_status_t, .offset = offsetof(asset_manager_asset_file_data_t, load_status), .size = sizeof(asset_slot_load_status_t)},
		.file_info = {.name = "file_info", .type = TYPE_file_t, .offset = offsetof(asset_manager_asset_file_data_t, file_info), .size = sizeof(file_t)},
		.raw_file_data = {.name = "raw_file_data", .type = TYPE_string_t, .offset = offsetof(asset_manager_asset_file_data_t, raw_file_data), .size = sizeof(string_t)},
		.package_entries = {.name = "package_entries", .type = TYPE_jfd_package_entry_t, .offset = offsetof(asset_manager_asset_file_data_t, package_entries), .size = sizeof(jfd_package_entry_t*)},
		.package_entry_count = {.name = "package_entry_count", .type = TYPE_u32, .offset = offsetof(asset_manager_asset_file_data_t, package_entry_count), .size = sizeof(u32)},
		.entry_hash = {.name = "entry_hash", .type = TYPE_s32, .offset = offsetof(asset_manager_asset_file_data_t, entry_hash), .size = sizeof(s32)},
		.header_data = {.name = "header_data", .type = TYPE_jfd_file_header_t, .offset = offsetof(asset_manager_asset_file_data_t, header_data), .size = sizeof(jfd_file_header_t*)},
	}
};

const static type_info_asset_catalog_t type_info_asset_catalog_t = {
	.name = "asset_catalog_t",
	.type = TYPE_asset_catalog_t,
	.member_count = 4,
	.members = {
		.ID = {.name = "ID", .type = TYPE_u32, .offset = offsetof(asset_catalog_t, ID), .size = sizeof(u32)},
		.catalog_type = {.name = "catalog_type", .type = TYPE_asset_type_t, .offset = offsetof(asset_catalog_t, catalog_type), .size = sizeof(asset_type_t)},
		.asset_manager = {.name = "asset_manager", .type = TYPE_asset_manager_t, .offset = offsetof(asset_catalog_t, asset_manager), .size = sizeof(asset_manager_t*)},
		.asset_lookup = {.name = "asset_lookup", .type = TYPE_asset_slot_t, .offset = offsetof(asset_catalog_t, asset_lookup), .size = sizeof(asset_slot_t)},
	}
};

const static type_info_texture_atlas_registry_t type_info_texture_atlas_registry_t = {
	.name = "texture_atlas_registry_t",
	.type = TYPE_texture_atlas_registry_t,
	.member_count = 2,
	.members = {
		.atlases = {.name = "atlases", .type = TYPE_texture_atlas_t, .offset = offsetof(texture_atlas_registry_t, atlases), .size = sizeof(texture_atlas_t)},
		.current_atlas_count = {.name = "current_atlas_count", .type = TYPE_u32, .offset = offsetof(texture_atlas_registry_t, current_atlas_count), .size = sizeof(u32)},
	}
};

const static type_info_asset_manager_t type_info_asset_manager_t = {
	.name = "asset_manager_t",
	.type = TYPE_asset_manager_t,
	.member_count = 13,
	.members = {
		.is_initialized = {.name = "is_initialized", .type = TYPE_bool8, .offset = offsetof(asset_manager_t, is_initialized), .size = sizeof(bool8)},
		.manager_arena = {.name = "manager_arena", .type = TYPE_memory_arena_t, .offset = offsetof(asset_manager_t, manager_arena), .size = sizeof(memory_arena_t)},
		.asset_files = {.name = "asset_files", .type = TYPE_asset_manager_asset_file_data_t, .offset = offsetof(asset_manager_t, asset_files), .size = sizeof(asset_manager_asset_file_data_t)},
		.asset_name_to_file = {.name = "asset_name_to_file", .type = TYPE_s32, .offset = offsetof(asset_manager_t, asset_name_to_file), .size = sizeof(s32)},
		.loaded_file_count = {.name = "loaded_file_count", .type = TYPE_u32, .offset = offsetof(asset_manager_t, loaded_file_count), .size = sizeof(u32)},
		.asset_load_queue = {.name = "asset_load_queue", .type = TYPE_asset_slot_t, .offset = offsetof(asset_manager_t, asset_load_queue), .size = sizeof(asset_slot_t*)},
		.asset_unload_queue = {.name = "asset_unload_queue", .type = TYPE_asset_slot_t, .offset = offsetof(asset_manager_t, asset_unload_queue), .size = sizeof(asset_slot_t*)},
		.atlas_registry = {.name = "atlas_registry", .type = TYPE_texture_atlas_registry_t, .offset = offsetof(asset_manager_t, atlas_registry), .size = sizeof(texture_atlas_registry_t)},
		.asset_allocator = {.name = "asset_allocator", .type = TYPE_zone_allocator_t, .offset = offsetof(asset_manager_t, asset_allocator), .size = sizeof(zone_allocator_t*)},
		.asset_catalogs = {.name = "asset_catalogs", .type = TYPE_asset_catalog_t, .offset = offsetof(asset_manager_t, asset_catalogs), .size = sizeof(asset_catalog_t)},
		.texture_catalog = {.name = "texture_catalog", .type = TYPE_asset_catalog_t, .offset = offsetof(asset_manager_t, texture_catalog), .size = sizeof(asset_catalog_t*)},
		.shader_catalog = {.name = "shader_catalog", .type = TYPE_asset_catalog_t, .offset = offsetof(asset_manager_t, shader_catalog), .size = sizeof(asset_catalog_t*)},
		.render_context = {.name = "render_context", .type = TYPE_vulkan_render_context_t, .offset = offsetof(asset_manager_t, render_context), .size = sizeof(vulkan_render_context_t*)},
	}
};

const static type_info_action_button_t type_info_action_button_t = {
	.name = "action_button_t",
	.type = TYPE_action_button_t,
	.member_count = 4,
	.members = {
		.is_down = {.name = "is_down", .type = TYPE_bool8, .offset = offsetof(action_button_t, is_down), .size = sizeof(bool8)},
		.is_released = {.name = "is_released", .type = TYPE_bool8, .offset = offsetof(action_button_t, is_released), .size = sizeof(bool8)},
		.is_pressed = {.name = "is_pressed", .type = TYPE_bool8, .offset = offsetof(action_button_t, is_pressed), .size = sizeof(bool8)},
		.half_transition_counter = {.name = "half_transition_counter", .type = TYPE_u8, .offset = offsetof(action_button_t, half_transition_counter), .size = sizeof(u8)},
	}
};

const static type_info_keyboard_controller_data_t type_info_keyboard_controller_data_t = {
	.name = "keyboard_controller_data_t",
	.type = TYPE_keyboard_controller_data_t,
	.member_count = 7,
	.members = {
		.input = {.name = "input", .type = TYPE_action_button_t, .offset = offsetof(keyboard_controller_data_t, input), .size = sizeof(action_button_t)},
		.current_mouse_pos = {.name = "current_mouse_pos", .type = TYPE_vec2_t, .offset = offsetof(keyboard_controller_data_t, current_mouse_pos), .size = sizeof(vec2_t)},
		.last_mouse_pos = {.name = "last_mouse_pos", .type = TYPE_vec2_t, .offset = offsetof(keyboard_controller_data_t, last_mouse_pos), .size = sizeof(vec2_t)},
		.mouse_delta = {.name = "mouse_delta", .type = TYPE_vec2_t, .offset = offsetof(keyboard_controller_data_t, mouse_delta), .size = sizeof(vec2_t)},
		.is_shift_key_down = {.name = "is_shift_key_down", .type = TYPE_bool8, .offset = offsetof(keyboard_controller_data_t, is_shift_key_down), .size = sizeof(bool8)},
		.is_control_key_down = {.name = "is_control_key_down", .type = TYPE_bool8, .offset = offsetof(keyboard_controller_data_t, is_control_key_down), .size = sizeof(bool8)},
		.is_alt_key_down = {.name = "is_alt_key_down", .type = TYPE_bool8, .offset = offsetof(keyboard_controller_data_t, is_alt_key_down), .size = sizeof(bool8)},
	}
};

const static type_info_analog_button_t type_info_analog_button_t = {
	.name = "analog_button_t",
	.type = TYPE_analog_button_t,
	.member_count = 2,
	.members = {
		.deadzone = {.name = "deadzone", .type = TYPE_s16, .offset = offsetof(analog_button_t, deadzone), .size = sizeof(s16)},
		.value = {.name = "value", .type = TYPE_s16, .offset = offsetof(analog_button_t, value), .size = sizeof(s16)},
	}
};

const static type_info_gamepad_controller_data_t type_info_gamepad_controller_data_t = {
	.name = "gamepad_controller_data_t",
	.type = TYPE_gamepad_controller_data_t,
	.member_count = 7,
	.members = {
		.gamepad_data = {.name = "gamepad_data", .type = TYPE_SDL_Gamepad, .offset = offsetof(gamepad_controller_data_t, gamepad_data), .size = sizeof(SDL_Gamepad*)},
		.stick_data = {.name = "stick_data", .type = TYPE_SDL_Joystick, .offset = offsetof(gamepad_controller_data_t, stick_data), .size = sizeof(SDL_Joystick*)},
		.gamepad_id = {.name = "gamepad_id", .type = TYPE_u32, .offset = offsetof(gamepad_controller_data_t, gamepad_id), .size = sizeof(u32)},
		.has_rumble = {.name = "has_rumble", .type = TYPE_bool8, .offset = offsetof(gamepad_controller_data_t, has_rumble), .size = sizeof(bool8)},
		.rumble_value = {.name = "rumble_value", .type = TYPE_s32, .offset = offsetof(gamepad_controller_data_t, rumble_value), .size = sizeof(s32)},
		.digital_buttons = {.name = "digital_buttons", .type = TYPE_action_button_t, .offset = offsetof(gamepad_controller_data_t, digital_buttons), .size = sizeof(action_button_t)},
		.analog_buttons = {.name = "analog_buttons", .type = TYPE_analog_button_t, .offset = offsetof(gamepad_controller_data_t, analog_buttons), .size = sizeof(analog_button_t)},
	}
};

const static type_info_input_controller_t type_info_input_controller_t = {
	.name = "input_controller_t",
	.type = TYPE_input_controller_t,
	.member_count = 5,
	.members = {
		.is_valid = {.name = "is_valid", .type = TYPE_bool8, .offset = offsetof(input_controller_t, is_valid), .size = sizeof(bool8)},
		.is_analog = {.name = "is_analog", .type = TYPE_bool8, .offset = offsetof(input_controller_t, is_analog), .size = sizeof(bool8)},
		.type = {.name = "type", .type = TYPE_controller_type_t, .offset = offsetof(input_controller_t, type), .size = sizeof(controller_type_t)},
		.keyboard = {.name = "keyboard", .type = TYPE_keyboard_controller_data_t, .offset = offsetof(input_controller_t, keyboard), .size = sizeof(keyboard_controller_data_t)},
		.gamepad = {.name = "gamepad", .type = TYPE_gamepad_controller_data_t, .offset = offsetof(input_controller_t, gamepad), .size = sizeof(gamepad_controller_data_t)},
	}
};

const static type_info_game_action_binding_t type_info_game_action_binding_t = {
	.name = "game_action_binding_t",
	.type = TYPE_game_action_binding_t,
	.member_count = 2,
	.members = {
		.type = {.name = "type", .type = TYPE_u32, .offset = offsetof(game_action_binding_t, type), .size = sizeof(u32)},
		.binding_id = {.name = "binding_id", .type = TYPE_u32, .offset = offsetof(game_action_binding_t, binding_id), .size = sizeof(u32)},
	}
};

const static type_info_game_action_t type_info_game_action_t = {
	.name = "game_action_t",
	.type = TYPE_game_action_t,
	.member_count = 3,
	.members = {
		.keyboard = {.name = "keyboard", .type = TYPE_game_action_binding_t, .offset = offsetof(game_action_t, keyboard), .size = sizeof(game_action_binding_t)},
		.gamepad = {.name = "gamepad", .type = TYPE_game_action_binding_t, .offset = offsetof(game_action_t, gamepad), .size = sizeof(game_action_binding_t)},
		.name = {.name = "name", .type = TYPE_string_t, .offset = offsetof(game_action_t, name), .size = sizeof(string_t)},
	}
};

const static type_info_input_manager_t type_info_input_manager_t = {
	.name = "input_manager_t",
	.type = TYPE_input_manager_t,
	.member_count = 7,
	.members = {
		.keyboard_data = {.name = "keyboard_data", .type = TYPE_keyboard_controller_data_t, .offset = offsetof(input_manager_t, keyboard_data), .size = sizeof(keyboard_controller_data_t)},
		.gamepad_data = {.name = "gamepad_data", .type = TYPE_gamepad_controller_data_t, .offset = offsetof(input_manager_t, gamepad_data), .size = sizeof(gamepad_controller_data_t)},
		.primary_controller_index = {.name = "primary_controller_index", .type = TYPE_u32, .offset = offsetof(input_manager_t, primary_controller_index), .size = sizeof(u32)},
		.active_controller_index = {.name = "active_controller_index", .type = TYPE_u32, .offset = offsetof(input_manager_t, active_controller_index), .size = sizeof(u32)},
		.connected_controller_count = {.name = "connected_controller_count", .type = TYPE_u32, .offset = offsetof(input_manager_t, connected_controller_count), .size = sizeof(u32)},
		.controllers = {.name = "controllers", .type = TYPE_input_controller_t, .offset = offsetof(input_manager_t, controllers), .size = sizeof(input_controller_t)},
		.game_actions = {.name = "game_actions", .type = TYPE_game_action_t, .offset = offsetof(input_manager_t, game_actions), .size = sizeof(game_action_t)},
	}
};

const static type_info_packet_t type_info_packet_t = {
	.name = "packet_t",
	.type = TYPE_packet_t,
	.member_count = 4,
	.members = {
		.magic_value = {.name = "magic_value", .type = TYPE_u32, .offset = offsetof(packet_t, magic_value), .size = sizeof(u32)},
		.type = {.name = "type", .type = TYPE_u32, .offset = offsetof(packet_t, type), .size = sizeof(u32)},
		.client_id = {.name = "client_id", .type = TYPE_u32, .offset = offsetof(packet_t, client_id), .size = sizeof(u32)},
		.input_data = {.name = "input_data", .type = TYPE_input_data_t, .offset = offsetof(packet_t, input_data), .size = sizeof(input_data_t)},
	}
};

#endif // GENERATED_PROGRAM_TYPES_H

