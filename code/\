/* ========================================================================
   $File: main.cpp $
   $Date: November 28 2025 06:40 pm $
   $Revision: $
   $Creator: Justin Lewis $
   ======================================================================== */
#include <SDL3/SDL.h>
#include <vulkan/vulkan.h>
#include <slang.h>

#include <stdio.h>

#include <c_base.h>
#include <c_types.h>
#include <c_math.h>

struct string_t 
{
    byte *data;
    u32   count;
};

#define MAX_VERTICES (1000)
struct vertex_t
{
    vec4_t position;
};

global_variable bool8 g_running;

string_t 
c_read_file(char *path)
{
    string_t result;

    FILE *file_handle = fopen(path, "rb");
    Expect(file_handle != null, "Could not read file: '%s'...\n", path);

    fseek(file_handle, 0, SEEK_END);
    u32 file_size = ftell(file_handle);
    fseek(file_handle, 0, SEEK_SET);

    Expect(file_size > 0, "File size is 0...\n");

    result.count = file_size;
    result.data  = (byte*)AllocSize(sizeof(byte) * file_size);
    Expect(result.data, "Failed to malloc data...\n");

    fread(result.data, 
          sizeof(byte), 
          file_size, 
          file_handle); 
    fclose(file_handle);

    return(result);
}

int
main(void)
{
    if(SDL_Init(SDL_INIT_VIDEO))
    {
        SDL_Window *window = SDL_CreateWindow("Window", 1280, 720, SDL_WINDOW_BORDERLESS);
        if(window)
        {
            SDL_GPUDevice *device = SDL_CreateGPUDevice(SDL_GPU_SHADERFORMAT_SPIRV|
                                                        SDL_GPU_SHADERFORMAT_DXIL|
                                                        SDL_GPU_SHADERFORMAT_MSL,
                                                        true,
                                                        null);
            Expect(device, "Failed to create GPU device...\n");
            Expect(SDL_ClaimWindowForGPUDevice(device, window), 
                   "Error, Failure to apply GPUDevice to that of the SDL Window: '%s'...\n", SDL_GetError());

            string_t v_shader_spirv = c_read_file("../code/shaders/test_vert.spv");
            SDL_GPUShaderCreateInfo v_shader_create_info = {
                .code_size  = v_shader_spirv.count,
                .code       = v_shader_spirv.data,
                .entrypoint = "main",
                .format     = SDL_GPU_SHADERFORMAT_SPIRV,
                .stage      = SDL_GPU_SHADERSTAGE_VERTEX,
            };

            string_t f_shader_spirv = c_read_file("../code/shaders/test_frag.spv");
            SDL_GPUShaderCreateInfo f_shader_create_info = {
                .code_size  = f_shader_spirv.count,
                .code       = f_shader_spirv.data,
                .entrypoint = "main",
                .format     = SDL_GPU_SHADERFORMAT_SPIRV,
                .stage      = SDL_GPU_SHADERSTAGE_FRAGMENT,
            };


            SDL_GPUShader *vertex_shader = SDL_CreateGPUShader(device,   &v_shader_create_info);
            SDL_GPUShader *fragment_shader = SDL_CreateGPUShader(device, &f_shader_create_info);

            Expect(vertex_shader, "%s...\n",   SDL_GetError());
            Expect(fragment_shader, "%s...\n", SDL_GetError());

            g_running = true;
            while(g_running)
            {
                SDL_Event event;
                while(SDL_PollEvent(&event))
                {
                    switch(event.type)
                    {
                        case SDL_EVENT_QUIT:
                        {
                            g_running = false;
                        }break;
                    }
                }
                SDL_GPUCommandBuffer *buffer = SDL_AcquireGPUCommandBuffer(device);

                SDL_GPUTexture *texture = null;
                SDL_WaitAndAcquireGPUSwapchainTexture(buffer, window, &texture, null, null);

                SDL_GPUColorTargetInfo colorTargetInfo = {
                    .texture = texture,
                    .clear_color = {0.0f, 0.0f, 1.0f, 1.0f}, 
                    .load_op = SDL_GPU_LOADOP_CLEAR, 
                    .store_op = SDL_GPU_STOREOP_STORE, 
                    .cycle = true, 
                };

                SDL_GPURenderPass *renderPass = SDL_BeginGPURenderPass(buffer, &colorTargetInfo, 1, NULL);
                SDL_EndGPURenderPass(renderPass);

                SDL_SubmitGPUCommandBuffer(buffer);
            }
        }
        else
        {
            printf("Error... Failure to create the SDL Window...: '%s'\n", SDL_GetError());
        }
    }
    else
    {
        printf("Error... Failure to init SDL3: '%s'\n", SDL_GetError());
    }

    return(0);
}
